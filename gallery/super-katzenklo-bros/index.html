<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SUPER KATZENKLO BROS</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #5c94fc; overflow: hidden; font-family: 'Comic Sans MS', 'Chalkboard SE', cursive; }
canvas { display: block; }
#title-screen {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    background: linear-gradient(180deg, #5c94fc 0%, #88b4fc 60%, #60b830 60%, #48a018 100%);
    z-index: 20;
}
#title-screen h1 {
    font-size: 3.5em; color: #FFD700; text-shadow: 4px 4px 0 #c84100, -1px -1px 0 #fff;
    animation: bounce 0.5s infinite alternate; text-align: center; line-height: 1.1;
}
#title-screen .subtitle { font-size: 1.3em; color: #fff; margin: 10px 0; text-shadow: 2px 2px 0 #2a6e00; }
#title-screen .meme-cat { font-size: 7em; animation: wiggle 0.8s infinite alternate; }
#title-screen .start-text { font-size: 1.8em; color: #FFD700; margin-top: 20px; animation: blink 1s infinite; text-shadow: 2px 2px 0 #8B4513; }
#title-screen .controls { font-size: 0.9em; color: #fff; margin-top: 15px; text-align: center; line-height: 1.8; text-shadow: 1px 1px 0 #2a6e00; }
#game-over {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    background: rgba(0,0,0,0.7); z-index: 30;
}
#game-over h2 { font-size: 3em; color: #FF4444; text-shadow: 3px 3px 0 #000; }
#game-over .meme-text { font-size: 1.5em; color: #FF69B4; margin: 10px 0; }
#game-over .score-text { font-size: 2em; color: #FFD700; }
#game-over .restart { font-size: 1.5em; color: #00FF00; margin-top: 15px; animation: blink 1s infinite; }
#hud { position: absolute; top: 10px; left: 10px; right: 10px; display: none; justify-content: space-between; z-index: 15; pointer-events: none; }
#hud .stat { font-size: 1.4em; color: #fff; text-shadow: 2px 2px 0 #000; background: rgba(0,0,0,0.3); padding: 5px 15px; border-radius: 20px; }
@keyframes bounce { to { transform: translateY(-10px); } }
@keyframes blink { 50% { opacity: 0.3; } }
@keyframes wiggle { 0% { transform: rotate(-5deg); } 100% { transform: rotate(5deg); } }
</style>
</head>
<body>

<div id="title-screen">
    <div class="meme-cat">üê±</div>
    <h1>SUPER<br>KATZENKLO<br>BROS</h1>
    <div class="subtitle">~ das memigste Katzenspiel aller Zeiten ~</div>
    <div class="start-text">LEERTASTE / KLICK zum Starten</div>
    <div class="controls">
        ‚å®Ô∏è Pfeile/WASD = Laufen &amp; Springen | üéÆ Gamepad = D-Pad + Buttons<br>
        üêü Fische sammeln | ü•í Gurken ausweichen | üí© Katzenklos = Plattformen<br>
        üì¶ Boxen = Katzen lieben Boxen | üî¥ Laserpointer = SPEED!
    </div>
</div>

<div id="game-over">
    <h2>GAME OVER</h2>
    <div class="meme-text" id="death-meme"></div>
    <div class="score-text" id="final-score"></div>
    <div class="restart">LEERTASTE zum Nochmal</div>
</div>

<div id="hud" style="display:none">
    <div class="stat" id="score-display">üêü 0</div>
    <div class="stat" id="lives-display">‚ù§Ô∏è 9</div>
    <div class="stat" id="combo-display"></div>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const ZOOM = 2.5;
let groundY = 0;
function vw() { return canvas.width / ZOOM; }
function vh() { return canvas.height / ZOOM; }
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; groundY = vh() * GROUND_Y_RATIO; }
resize(); window.addEventListener('resize', resize);

// ============= CONSTANTS =============
const GRAVITY = 0.55;
const JUMP_FORCE = -13;
const MOVE_SPEED = 5;
const MAX_SPEED = 7;
const GROUND_Y_RATIO = 0.88; // ground at 88% ‚Äî thin earth strip at bottom
const TILE = 32;

// ============= MEME DATA =============
const MEMES_JUMP = ["much jump!", "BOING!", "nyoom!", "hops!", "WHEEE!", "purrfect jump!", "such spring!"];
const MEMES_COLLECT = ["om nom!", "FISCH!", "lecker!", "yummy!", "I CAN HAS FISH!", "tasty!", "meow yeah!"];
const MEMES_DEATH = [
    "ded üíÄ", "skill issue tbh", "F in chat", "L + ratio + Gurke",
    "die Gurke hat gewonnen", "not stonks üìâ", "respawn...",
    "Katze.exe stopped", "oof size: MEGA", "so sad. much ded.",
];
const MEMES_COMBO = ["COMBO!", "MEGA MIAU!", "ULTRA!", "UNGLAUBLICH!", "GOTT-KATZE!", "NYAN!"];
const MEMES_RANDOM = [
    "I CAN HAS CHEEZBURGER?", "if i fits i sits", "ceiling cat is watching",
    "long cat is loooong", "Katzenklo, Katzenklo, ja das macht die Katze froh!",
    "NYAN NYAN NYAN", "monorail cat", "business cat approves",
    "keyboard cat plays you off", "grumpy cat says NO",
    "dis is mah box", "you has flavor", "invisible sandwich",
    "hover cat activaed", "cat.exe has stopped working",
];

// Big meme "billboards" that appear in the background
const MEME_SIGNS = [
    { text: "I CAN HAS\nCHEEZBURGER?", emoji: "üçî", bg: "#FFD700" },
    { text: "CEILING CAT\nIS WATCHING U", emoji: "üëÅÔ∏è", bg: "#87CEEB" },
    { text: "GRUMPY CAT\nSAYS: NO.", emoji: "üòæ", bg: "#DDA0DD" },
    { text: "IF I FITS\nI SITS", emoji: "üì¶", bg: "#DEB887" },
    { text: "NYAN NYAN\nNYAN NYAN", emoji: "üåà", bg: "#FF69B4" },
    { text: "LONG CAT IS\nLOOOOONG", emoji: "üê±", bg: "#90EE90" },
    { text: "KEYBOARD CAT\nPLAYS U OFF", emoji: "üéπ", bg: "#FFA07A" },
    { text: "INVISIBLE\nSANDWICH", emoji: "ü•™", bg: "#F0E68C" },
    { text: "BUSINESS CAT\nAPPROVES", emoji: "üëî", bg: "#B0C4DE" },
    { text: "HOVER CAT\nACTIVATED", emoji: "üõ∏", bg: "#E6E6FA" },
    { text: "DIS IS\nMAH BOX", emoji: "üì¶", bg: "#FFDAB9" },
    { text: "MUCH WOW\nSUCH CAT", emoji: "üêï", bg: "#98FB98" },
    { text: "TACO CAT\nSPELLED\nBACKWARDS\nIS TACO CAT", emoji: "üåÆ", bg: "#FFE4B5" },
    { text: "MONORAIL\nCAT", emoji: "üöù", bg: "#ADD8E6" },
    { text: "ERROR 404\nCAT NOT FOUND", emoji: "‚ùì", bg: "#FFC0CB" },
];

// ============= AUDIO =============
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(freq, dur, type, vol) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type || 'square'; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(freq * 0.5, audioCtx.currentTime + dur);
    gain.gain.setValueAtTime(vol || 0.12, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + dur);
}
function sfxJump() { playSound(500, 0.12, 'square', 0.1); setTimeout(() => playSound(700, 0.08, 'square', 0.08), 40); }
function sfxCollect() { playSound(900, 0.08, 'sine', 0.12); setTimeout(() => playSound(1300, 0.12, 'sine', 0.1), 60); }
function sfxDeath() { playSound(200, 0.5, 'sawtooth', 0.18); }
function sfxCombo() { [900,1100,1300,1600].forEach((f,i) => setTimeout(() => playSound(f, 0.08, 'sine', 0.1), i*50)); }
function sfxBox() { playSound(300, 0.15, 'square', 0.1); playSound(600, 0.1, 'sine', 0.08); }
function sfxLaser() { playSound(1500, 0.2, 'sine', 0.1); setTimeout(() => playSound(2000, 0.15, 'sine', 0.08), 50); }

// ============= MUSIC =============
const musicTracks = [
    new Audio('skb-track-10.mp3'),
    new Audio('skb-track-11.mp3'),
];
musicTracks.forEach(t => { t.loop = true; t.volume = 0.35; });
let currentTrack = null;

function musicStart() {
    if (currentTrack) { currentTrack.pause(); currentTrack.currentTime = 0; }
    currentTrack = musicTracks[Math.floor(Math.random() * musicTracks.length)];
    currentTrack.play().catch(() => {});
}
function musicStop() { if (currentTrack) { currentTrack.pause(); currentTrack.currentTime = 0; } }
function musicPause() { if (currentTrack) currentTrack.pause(); }
function musicResume() { if (currentTrack) currentTrack.play().catch(() => {}); }

// ============= GAME STATE =============
let state = 'title';
let cat = {}, camera = {};
let score = 0, lives = 9, combo = 0, comboTimer = 0, frame = 0, highScore = 0;
let platforms = [], fishes = [], cucumbers = [], boxes = [], lasers = [], particles = [], memeTexts = [], signs = [];
let nyanTrail = []; // rainbow trail for combos
let speedBoost = 0;
function getGroundY() { return vh() * GROUND_Y_RATIO; }

// ============= WORLD GENERATION =============
function generateWorld() {
    groundY = getGroundY();
    platforms = []; fishes = []; cucumbers = []; boxes = []; lasers = []; signs = [];

    let px = 300;
    for (let i = 0; i < 300; i++) {
        const spacing = 120 + Math.random() * 180;
        const maxHeight = Math.min(60 + i * 1.5, 250); // platforms get higher as you progress
        const py = groundY - 50 - Math.random() * maxHeight;
        const pw = 70 + Math.random() * 100;

        platforms.push({ x: px, y: py, w: pw, h: 22 });

        // Fish on or above platform
        if (Math.random() > 0.2) {
            fishes.push({ x: px + pw/2, y: py - 25 - Math.random()*30, alive: true });
        }
        // Extra floating fish
        if (Math.random() > 0.65) {
            fishes.push({ x: px + pw * Math.random(), y: py - 60 - Math.random()*50, alive: true });
        }

        // Fish on ground between platforms
        if (Math.random() > 0.5) {
            fishes.push({ x: px - spacing * 0.4, y: groundY - 25, alive: true });
        }

        // Cucumbers (enemies) ‚Äî start appearing after platform 6
        if (i > 6 && Math.random() > Math.max(0.35, 0.85 - i * 0.015)) {
            cucumbers.push({
                x: px + pw/2, y: groundY - 18,
                vx: (Math.random() > 0.5 ? 1 : -1) * (0.8 + Math.random()*1.5),
                left: px - 30, right: px + pw + 30,
                alive: true, onPlatform: false,
            });
        }
        // Cucumber on platform (later)
        if (i > 12 && Math.random() > 0.7) {
            cucumbers.push({
                x: px + pw/2, y: py - 18,
                vx: (Math.random() > 0.5 ? 1 : -1) * (0.5 + Math.random()),
                left: px, right: px + pw,
                alive: true, onPlatform: true,
            });
        }

        // Boxes (cats love boxes!) ‚Äî give bonus points
        if (Math.random() > 0.75) {
            boxes.push({ x: px + pw * Math.random(), y: groundY - 20, alive: true, type: Math.random() > 0.5 ? 'box' : 'catloaf' });
        }

        // Laser pointer (speed boost!) ‚Äî rare
        if (Math.random() > 0.9) {
            lasers.push({ x: px + spacing * 0.5, y: groundY - 25 - Math.random() * 80, alive: true });
        }

        // Meme signs in background
        if (i % 4 === 0) {
            const sign = MEME_SIGNS[Math.floor(Math.random() * MEME_SIGNS.length)];
            signs.push({ x: px + Math.random() * 200, y: groundY - 120 - Math.random() * 100, ...sign });
        }

        px += spacing;
    }
}

function reset() {
    groundY = getGroundY();
    cat = { x: 100, y: groundY - 30, vx: 0, vy: 0, dir: 1, grounded: true, size: 28 };
    camera = { x: 0, y: groundY - vh() * 0.88 };
    score = 0; lives = 9; combo = 0; comboTimer = 0; speedBoost = 0;
    particles = []; memeTexts = []; nyanTrail = [];
    generateWorld();
}

// ============= DRAWING FUNCTIONS =============
function drawSky() {
    // Blue sky gradient ‚Äî extend high above to cover vertical scrolling
    const skyTop = groundY - vh() * 2;
    const grad = ctx.createLinearGradient(0, skyTop, 0, groundY);
    grad.addColorStop(0, '#3a7ae5');
    grad.addColorStop(0.3, '#4a8af5');
    grad.addColorStop(0.7, '#6da6fc');
    grad.addColorStop(1, '#92c4ff');
    ctx.fillStyle = grad;
    ctx.fillRect(0, skyTop, vw(), groundY - skyTop);

    // Sun (stays relative to viewport via camera.y offset)
    const sunX = vw() - 50 + Math.sin(frame * 0.003) * 10;
    const sunY = camera.y + 40;
    ctx.fillStyle = '#FFF8DC';
    ctx.beginPath(); ctx.arc(sunX - camera.x * 0.02, sunY, 22, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#FFD700';
    ctx.beginPath(); ctx.arc(sunX - camera.x * 0.02, sunY, 18, 0, Math.PI*2); ctx.fill();
    // Sun rays
    ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.3;
    for (let i = 0; i < 12; i++) {
        const a = (i/12) * Math.PI*2 + frame*0.01;
        ctx.beginPath();
        ctx.moveTo(sunX - camera.x*0.02 + Math.cos(a)*24, sunY + Math.sin(a)*24);
        ctx.lineTo(sunX - camera.x*0.02 + Math.cos(a)*32, sunY + Math.sin(a)*32);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Clouds (parallax, relative to viewport)
    ctx.fillStyle = '#fff';
    for (let i = 0; i < 15; i++) {
        const cx = ((i * 180 + 50) - camera.x * 0.1) % (vw() + 200) - 100;
        const cy = camera.y + 20 + (i * 37) % 60;
        const cw = 30 + (i * 17) % 25;
        ctx.globalAlpha = 0.8;
        ctx.beginPath(); ctx.arc(cx, cy, cw*0.3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + cw*0.25, cy - cw*0.1, cw*0.35, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + cw*0.5, cy, cw*0.28, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Background hills (parallax)
    ctx.fillStyle = '#5ab83a';
    for (let i = 0; i < 20; i++) {
        const hx = i * 140 - (camera.x * 0.2) % 140 - 140;
        ctx.beginPath();
        ctx.arc(hx, groundY + 5, 70 + Math.sin(i*1.7)*20, Math.PI, 0);
        ctx.fill();
    }
    // Foreground hills
    ctx.fillStyle = '#4da832';
    for (let i = 0; i < 25; i++) {
        const hx = i * 100 - (camera.x * 0.35) % 100 - 100;
        ctx.beginPath();
        ctx.arc(hx, groundY + 5, 45 + Math.sin(i*2.3)*15, Math.PI, 0);
        ctx.fill();
    }
}

function drawGround() {
    // Main ground ‚Äî thin green strip
    ctx.fillStyle = '#4da832';
    ctx.fillRect(0, groundY, vw(), 8);
    // Darker earth below ‚Äî extends far down to cover any camera position
    ctx.fillStyle = '#8B5E3C';
    ctx.fillRect(0, groundY + 8, vw(), vh() * 2);
    // Grass tufts on top
    ctx.fillStyle = '#5cc43c';
    for (let i = 0; i < vw() + 20; i += 8) {
        ctx.beginPath();
        ctx.moveTo(i - 3, groundY + 1);
        ctx.lineTo(i, groundY - 3 - Math.sin(frame*0.05 + i*0.1)*1.5);
        ctx.lineTo(i + 3, groundY + 1);
        ctx.fill();
    }
}

function drawKatzenklo(x, y, w, h) {
    // Box
    ctx.fillStyle = '#a09070';
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = '#c0b090';
    ctx.fillRect(x+3, y+3, w-6, h-6);
    // Sand dots
    ctx.fillStyle = '#d4c8a0';
    for (let i = 0; i < 6; i++) {
        ctx.fillRect(x + 6 + Math.random()*(w-12), y + 4 + Math.random()*(h-8), 2, 2);
    }
    // Label
    ctx.fillStyle = '#6b5b3a';
    ctx.font = `bold ${Math.min(11, w/7)}px Comic Sans MS, cursive`;
    ctx.textAlign = 'center';
    ctx.fillText('KATZENKLO', x + w/2, y + h/2 + 4);
    // Poop emoji on top
    ctx.font = '14px serif';
    ctx.fillText('üí©', x + w - 16, y - 2);
}

function drawCat(x, y, s, dir, fr) {
    ctx.save();
    ctx.translate(x, y);
    if (dir < 0) ctx.scale(-1, 1);
    // Body
    ctx.fillStyle = '#FF8C00';
    ctx.fillRect(-s*0.35, -s*0.25, s*0.7, s*0.5);
    // Head
    ctx.fillStyle = '#FFA500';
    ctx.beginPath(); ctx.arc(s*0.25, -s*0.35, s*0.3, 0, Math.PI*2); ctx.fill();
    // Ears
    ctx.fillStyle = '#FF8C00';
    ctx.beginPath(); ctx.moveTo(s*0.08,-s*0.6); ctx.lineTo(s*0.2,-s*0.78); ctx.lineTo(s*0.35,-s*0.6); ctx.fill();
    ctx.beginPath(); ctx.moveTo(s*0.28,-s*0.6); ctx.lineTo(s*0.42,-s*0.78); ctx.lineTo(s*0.5,-s*0.55); ctx.fill();
    // Inner ears
    ctx.fillStyle = '#FFB6C1';
    ctx.beginPath(); ctx.moveTo(s*0.14,-s*0.62); ctx.lineTo(s*0.22,-s*0.73); ctx.lineTo(s*0.3,-s*0.62); ctx.fill();
    // Eyes
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(s*0.16,-s*0.38, s*0.07, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(s*0.36,-s*0.38, s*0.07, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#FFF';
    ctx.beginPath(); ctx.arc(s*0.18,-s*0.40, s*0.025, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(s*0.38,-s*0.40, s*0.025, 0, Math.PI*2); ctx.fill();
    // Nose
    ctx.fillStyle = '#FF69B4';
    ctx.beginPath(); ctx.arc(s*0.27,-s*0.30, s*0.035, 0, Math.PI*2); ctx.fill();
    // Mouth
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.arc(s*0.27,-s*0.26, s*0.06, 0.1, Math.PI-0.1); ctx.stroke();
    // Whiskers
    ctx.strokeStyle = '#555'; ctx.lineWidth = 0.8;
    for (let w = -1; w <= 1; w++) {
        ctx.beginPath(); ctx.moveTo(s*0.05,-s*0.30+w*s*0.04); ctx.lineTo(-s*0.12,-s*0.30+w*s*0.07); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(s*0.48,-s*0.30+w*s*0.04); ctx.lineTo(s*0.65,-s*0.30+w*s*0.07); ctx.stroke();
    }
    // Legs
    ctx.fillStyle = '#FF8C00';
    const la = Math.sin(fr * 0.3) * s * 0.08;
    ctx.fillRect(-s*0.25, s*0.18, s*0.12, s*0.18+la);
    ctx.fillRect(-s*0.05, s*0.18, s*0.12, s*0.18-la);
    ctx.fillRect(s*0.12, s*0.18, s*0.12, s*0.18+la);
    ctx.fillRect(s*0.28, s*0.18, s*0.12, s*0.18-la);
    // Paws
    ctx.fillStyle = '#e87800';
    ctx.fillRect(-s*0.27, s*0.34+la, s*0.16, s*0.05);
    ctx.fillRect(-s*0.07, s*0.34-la, s*0.16, s*0.05);
    // Tail
    ctx.strokeStyle = '#FF8C00'; ctx.lineWidth = s*0.07; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(-s*0.35,-s*0.05);
    ctx.quadraticCurveTo(-s*0.6, -s*0.3 + Math.sin(fr*0.12)*s*0.15, -s*0.5, -s*0.55);
    ctx.stroke();
    ctx.restore();

    // Speed lines when boosted
    if (speedBoost > 0) {
        ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 2; ctx.globalAlpha = 0.5;
        for (let i = 0; i < 3; i++) {
            const ly = y - s*0.2 + i * s*0.2;
            ctx.beginPath();
            ctx.moveTo(x - dir * s * 0.5 - i*8, ly);
            ctx.lineTo(x - dir * s * 1.5 - i*12, ly);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
    }
}

function drawFish(x, y, size, fr) {
    ctx.save(); ctx.translate(x, y);
    ctx.rotate(Math.sin(fr * 0.08) * 0.15);
    // Shimmer
    const shimmer = 0.85 + Math.sin(fr * 0.15) * 0.15;
    ctx.globalAlpha = shimmer;
    ctx.fillStyle = '#00CED1';
    ctx.beginPath(); ctx.ellipse(0, 0, size, size*0.5, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#008B8B';
    ctx.beginPath(); ctx.moveTo(-size*0.7, 0); ctx.lineTo(-size*1.2, -size*0.5); ctx.lineTo(-size*1.2, size*0.5); ctx.closePath(); ctx.fill();
    ctx.fillStyle = '#FFF';
    ctx.beginPath(); ctx.arc(size*0.35, -size*0.1, size*0.12, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(size*0.4, -size*0.1, size*0.06, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
}

function drawCucumber(x, y, size, fr) {
    ctx.save(); ctx.translate(x, y);
    ctx.fillStyle = '#228B22';
    ctx.beginPath(); ctx.ellipse(0, 0, size*1.1, size*0.35, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#2E8B57';
    for (let i = -2; i <= 2; i++) { ctx.beginPath(); ctx.arc(i*size*0.35, -size*0.12, size*0.06, 0, Math.PI*2); ctx.fill(); }
    // Angry eyes
    ctx.fillStyle = '#FF0000';
    ctx.beginPath(); ctx.arc(-size*0.2, -size*0.05, size*0.09, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(size*0.2, -size*0.05, size*0.09, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.arc(-size*0.18, -size*0.05, size*0.04, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(size*0.22, -size*0.05, size*0.04, 0, Math.PI*2); ctx.fill();
    // Angry eyebrows
    ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(-size*0.3, -size*0.2); ctx.lineTo(-size*0.1, -size*0.15); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(size*0.3, -size*0.2); ctx.lineTo(size*0.1, -size*0.15); ctx.stroke();
    ctx.restore();
}

function drawBox(x, y, type) {
    if (type === 'catloaf') {
        // Cat loaf (cat sitting in loaf position)
        ctx.fillStyle = '#FF8C00';
        ctx.beginPath(); ctx.ellipse(x, y, 16, 10, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#FFA500';
        ctx.beginPath(); ctx.arc(x + 10, y - 8, 8, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000';
        ctx.fillRect(x + 7, y - 10, 2, 2); ctx.fillRect(x + 12, y - 10, 2, 2);
        ctx.fillStyle = '#FF69B4';
        ctx.beginPath(); ctx.arc(x + 10, y - 7, 1.5, 0, Math.PI*2); ctx.fill();
    } else {
        // Cardboard box
        ctx.fillStyle = '#D2B48C';
        ctx.fillRect(x - 15, y - 15, 30, 25);
        ctx.fillStyle = '#C4A87A';
        ctx.fillRect(x - 13, y - 13, 26, 21);
        ctx.strokeStyle = '#8B7355'; ctx.lineWidth = 1;
        ctx.strokeRect(x - 15, y - 15, 30, 25);
        // Flaps
        ctx.fillStyle = '#D2B48C';
        ctx.beginPath(); ctx.moveTo(x-15, y-15); ctx.lineTo(x-10, y-22); ctx.lineTo(x, y-15); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x, y-15); ctx.lineTo(x+10, y-22); ctx.lineTo(x+15, y-15); ctx.fill();
        // Text
        ctx.fillStyle = '#8B7355'; ctx.font = '8px Comic Sans MS'; ctx.textAlign = 'center';
        ctx.fillText('if i fits', x, y - 3);
        ctx.fillText('i sits', x, y + 7);
    }
}

function drawLaser(x, y, fr) {
    // Red dot that pulses
    const pulse = 0.6 + Math.sin(fr * 0.2) * 0.4;
    ctx.fillStyle = '#FF0000';
    ctx.globalAlpha = pulse;
    ctx.beginPath(); ctx.arc(x, y, 8, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = pulse * 0.4;
    ctx.beginPath(); ctx.arc(x, y, 14, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    // Beam going up
    ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.3;
    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + Math.sin(fr*0.05)*20, -100); ctx.stroke();
    ctx.globalAlpha = 1;
}

function drawSign(sign) {
    const x = sign.x, y = sign.y;
    // Background
    ctx.fillStyle = sign.bg; ctx.globalAlpha = 0.25;
    ctx.fillRect(x - 55, y - 40, 110, 80);
    ctx.globalAlpha = 1;
    // Border
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.globalAlpha = 0.2;
    ctx.strokeRect(x - 55, y - 40, 110, 80);
    ctx.globalAlpha = 1;
    // Emoji
    ctx.font = '28px serif'; ctx.textAlign = 'center';
    ctx.fillText(sign.emoji, x, y - 10);
    // Text
    ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.35;
    ctx.font = 'bold 9px Comic Sans MS, cursive';
    const lines = sign.text.split('\n');
    lines.forEach((line, i) => {
        ctx.fillText(line, x, y + 12 + i * 12);
    });
    ctx.globalAlpha = 1;
}

function drawNyanTrail() {
    if (nyanTrail.length < 2) return;
    const colors = ['#FF0000','#FF8800','#FFFF00','#00FF00','#0088FF','#8800FF'];
    for (let c = 0; c < colors.length; c++) {
        ctx.strokeStyle = colors[c]; ctx.lineWidth = 3; ctx.globalAlpha = 0.6;
        ctx.beginPath();
        for (let i = 0; i < nyanTrail.length; i++) {
            const p = nyanTrail[i];
            const ny = p.y + (c - 2.5) * 4;
            if (i === 0) ctx.moveTo(p.x, ny); else ctx.lineTo(p.x, ny);
        }
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
}

// ============= PARTICLES =============
function spawnParticles(x, y, color, count, speed) {
    for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2;
        particles.push({
            x, y, vx: Math.cos(a)*speed*(0.5+Math.random()), vy: Math.sin(a)*speed*(0.5+Math.random())-2,
            life: 1, decay: 0.02+Math.random()*0.03, color, size: 3+Math.random()*4,
        });
    }
}

function showMeme(text, x, y, color) {
    memeTexts.push({ text, x, y, vy: -1.5, life: 1, color: color || '#FF69B4', size: 20 + Math.random()*8 });
}

// ============= INPUT =============
const keys = {};
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if ((state === 'title' || state === 'dead') && (e.code === 'Space' || e.code === 'Enter')) {
        audioCtx.resume(); startGame();
    }
});
window.addEventListener('keyup', e => { keys[e.code] = false; });
canvas.addEventListener('click', () => {
    if (state === 'title' || state === 'dead') { audioCtx.resume(); startGame(); }
});

function startGame() {
    state = 'playing'; reset();
    document.getElementById('title-screen').style.display = 'none';
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('hud').style.display = 'flex';
    musicStart();
}

// Gamepad
let gpJumpPrev = false;
function pollGamepad() {
    const gps = navigator.getGamepads(); if (!gps) return;
    for (const gp of gps) {
        if (!gp) continue;
        if (gp.axes[0] < -0.3 || (gp.buttons[14] && gp.buttons[14].pressed)) keys['_gpLeft'] = true; else keys['_gpLeft'] = false;
        if (gp.axes[0] > 0.3 || (gp.buttons[15] && gp.buttons[15].pressed)) keys['_gpRight'] = true; else keys['_gpRight'] = false;
        let jump = false;
        for (const bi of [0,1,2,3,4,5,12]) { if (gp.buttons[bi] && gp.buttons[bi].pressed) jump = true; }
        if (gp.axes[1] < -0.5) jump = true;
        if (jump && !gpJumpPrev) keys['_gpJump'] = true;
        gpJumpPrev = jump;
        if (gp.buttons[9] && gp.buttons[9].pressed && state !== 'playing') { startGame(); }
    }
}

// ============= UPDATE =============
function update() {
    if (state !== 'playing') return;
    frame++;
    groundY = getGroundY();
    pollGamepad();

    // Movement
    let moveDir = 0;
    if (keys['ArrowLeft'] || keys['KeyA'] || keys['_gpLeft']) moveDir = -1;
    if (keys['ArrowRight'] || keys['KeyD'] || keys['_gpRight']) moveDir = 1;

    const curSpeed = speedBoost > 0 ? MAX_SPEED * 1.8 : MAX_SPEED;
    if (moveDir !== 0) { cat.vx += moveDir * MOVE_SPEED * 0.3; cat.dir = moveDir; }
    else cat.vx *= 0.85;
    cat.vx = Math.max(-curSpeed, Math.min(curSpeed, cat.vx));

    // Jump
    if ((keys['ArrowUp'] || keys['KeyW'] || keys['Space'] || keys['_gpJump']) && cat.grounded) {
        cat.vy = JUMP_FORCE;
        cat.grounded = false;
        sfxJump();
        spawnParticles(cat.x, cat.y + cat.size*0.3, '#90EE90', 4, 2);
        if (Math.random() > 0.65) showMeme(MEMES_JUMP[Math.floor(Math.random()*MEMES_JUMP.length)], cat.x, cat.y - 40);
    }
    keys['_gpJump'] = false;

    // Gravity
    cat.vy += GRAVITY;
    cat.x += cat.vx;
    cat.y += cat.vy;

    // Ground collision (SOLID GROUND - you never die from falling!)
    if (cat.y + cat.size * 0.35 >= groundY) {
        cat.y = groundY - cat.size * 0.35;
        cat.vy = 0;
        cat.grounded = true;
    }

    // Platform collision (land on top only)
    for (const p of platforms) {
        if (cat.x + cat.size*0.3 > p.x && cat.x - cat.size*0.3 < p.x + p.w) {
            if (cat.vy > 0 && cat.y + cat.size*0.35 > p.y && cat.y + cat.size*0.35 - cat.vy <= p.y + 5) {
                cat.y = p.y - cat.size*0.35;
                cat.vy = 0;
                cat.grounded = true;
            }
        }
    }

    // Nyan trail (when combo >= 3)
    if (combo >= 3) {
        nyanTrail.push({ x: cat.x, y: cat.y });
        if (nyanTrail.length > 30) nyanTrail.shift();
    } else {
        if (nyanTrail.length > 0) nyanTrail.shift();
    }

    // Fish
    for (const f of fishes) {
        if (!f.alive) continue;
        if (Math.abs(cat.x - f.x) < cat.size + 12 && Math.abs(cat.y - f.y) < cat.size + 12) {
            f.alive = false; score++; combo++; comboTimer = 90;
            sfxCollect();
            spawnParticles(f.x, f.y, '#00CED1', 6, 3);
            showMeme(MEMES_COLLECT[Math.floor(Math.random()*MEMES_COLLECT.length)], f.x, f.y - 20, '#00CED1');
            if (combo >= 3 && combo % 3 === 0) {
                sfxCombo();
                showMeme(MEMES_COMBO[Math.min(Math.floor(combo/3)-1, MEMES_COMBO.length-1)], cat.x, cat.y - 70, '#FFD700');
            }
            if (Math.random() > 0.88) showMeme(MEMES_RANDOM[Math.floor(Math.random()*MEMES_RANDOM.length)], cat.x + (Math.random()-0.5)*100, cat.y - 60, '#FF69B4');
        }
    }

    // Boxes
    for (const b of boxes) {
        if (!b.alive) continue;
        if (Math.abs(cat.x - b.x) < cat.size + 12 && Math.abs(cat.y - b.y) < cat.size + 10) {
            b.alive = false; score += 3; sfxBox();
            spawnParticles(b.x, b.y, '#D2B48C', 8, 3);
            showMeme(b.type === 'catloaf' ? "CATLOAF! +3 üçûüê±" : "IF I FITS I SITS! +3 üì¶", b.x, b.y - 25, '#DEB887');
        }
    }

    // Lasers
    for (const l of lasers) {
        if (!l.alive) continue;
        if (Math.abs(cat.x - l.x) < cat.size + 10 && Math.abs(cat.y - l.y) < cat.size + 10) {
            l.alive = false; speedBoost = 180; sfxLaser();
            spawnParticles(l.x, l.y, '#FF0000', 10, 5);
            showMeme("LASER! SPEED BOOST! üî¥üí®", l.x, l.y - 30, '#FF0000');
        }
    }
    if (speedBoost > 0) speedBoost--;

    // Cucumbers
    for (const c of cucumbers) {
        if (!c.alive) continue;
        c.x += c.vx;
        if (c.x < c.left || c.x > c.right) c.vx *= -1;
        const dx = cat.x - c.x, dy = cat.y - c.y;
        if (Math.sqrt(dx*dx+dy*dy) < cat.size + 12) {
            if (cat.vy > 0 && cat.y < c.y - 8) {
                // Stomp!
                c.alive = false; cat.vy = JUMP_FORCE * 0.65; score += 5; sfxCollect();
                spawnParticles(c.x, c.y, '#228B22', 10, 4);
                showMeme("GURKE ZERST√ñRT! ü•íüí•", c.x, c.y - 30, '#00FF00');
            } else {
                // Hit!
                lives--; sfxDeath(); combo = 0; nyanTrail = [];
                spawnParticles(cat.x, cat.y, '#FF0000', 12, 5);
                if (lives <= 0) { die(); return; }
                cat.vx = -cat.dir * 8; cat.vy = JUMP_FORCE * 0.8;
                showMeme(lives + " Leben! ü•íüòø", cat.x, cat.y - 40, '#FF4444');
            }
        }
    }

    // Combo decay
    if (comboTimer > 0) { comboTimer--; if (comboTimer <= 0) { combo = 0; nyanTrail = []; } }

    // Camera ‚Äî follows cat both horizontally and vertically
    camera.x += (cat.x - vw() * 0.35 - camera.x) * 0.08;
    // Y camera: follow cat upward, but don't go below ground level
    const targetY = cat.y - vh() * 0.55;
    const maxCamY = groundY - vh() * 0.88; // default ground-level view
    camera.y += (Math.min(targetY, maxCamY) - camera.y) * 0.1;

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life -= p.decay;
        if (p.life <= 0) particles.splice(i, 1);
    }
    // Meme texts
    for (let i = memeTexts.length - 1; i >= 0; i--) {
        memeTexts[i].y += memeTexts[i].vy; memeTexts[i].life -= 0.012;
        if (memeTexts[i].life <= 0) memeTexts.splice(i, 1);
    }

    // HUD
    document.getElementById('score-display').textContent = 'üêü ' + score;
    document.getElementById('lives-display').textContent = '‚ù§Ô∏è ' + lives;
    document.getElementById('combo-display').textContent = combo >= 2 ? 'üî• x' + combo + (speedBoost > 0 ? ' üî¥SPEED!' : '') : (speedBoost > 0 ? 'üî¥ SPEED!' : '');
}

function die() {
    state = 'dead';
    musicPause();
    if (score > highScore) highScore = score;
    document.getElementById('game-over').style.display = 'flex';
    document.getElementById('death-meme').textContent = MEMES_DEATH[Math.floor(Math.random()*MEMES_DEATH.length)];
    document.getElementById('final-score').textContent = 'üêü ' + score + ' Fische | Best: ' + highScore;
    document.getElementById('hud').style.display = 'none';
}

// ============= RENDER =============
function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.scale(ZOOM, ZOOM);

    if (state === 'title') { camera = camera || {x:0, y:0}; ctx.save(); ctx.translate(0, -camera.y); drawSky(); drawGround(); ctx.restore(); ctx.restore(); requestAnimationFrame(render); return; }

    // Translate for vertical camera (sky/ground are screen-relative but shift with camera.y)
    ctx.save();
    ctx.translate(0, -camera.y);
    drawSky();
    drawGround();
    ctx.restore();

    ctx.save();
    ctx.translate(-camera.x, -camera.y);

    // Signs (background, behind everything)
    for (const s of signs) {
        if (s.x > camera.x - 200 && s.x < camera.x + vw() + 200) drawSign(s);
    }

    // Nyan trail
    drawNyanTrail();

    // Platforms
    for (const p of platforms) {
        if (p.x + p.w > camera.x - 50 && p.x < camera.x + vw() + 50) drawKatzenklo(p.x, p.y, p.w, p.h);
    }

    // Boxes
    for (const b of boxes) { if (b.alive) drawBox(b.x, b.y, b.type); }

    // Lasers
    for (const l of lasers) { if (l.alive) drawLaser(l.x, l.y, frame); }

    // Fishes
    for (const f of fishes) { if (f.alive) drawFish(f.x, f.y, 11, frame); }

    // Cucumbers
    for (const c of cucumbers) { if (c.alive) drawCucumber(c.x, c.y, 16, frame); }

    // Particles
    for (const p of particles) {
        ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
        ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size*p.life, p.size*p.life);
    }
    ctx.globalAlpha = 1;

    // Meme texts
    for (const m of memeTexts) {
        ctx.globalAlpha = m.life; ctx.fillStyle = m.color;
        ctx.font = `bold ${m.size}px Comic Sans MS, cursive`;
        ctx.textAlign = 'center'; ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
        ctx.strokeText(m.text, m.x, m.y); ctx.fillText(m.text, m.x, m.y);
    }
    ctx.globalAlpha = 1;

    // Cat
    drawCat(cat.x, cat.y, cat.size, cat.dir, cat.grounded ? frame : 0);

    ctx.restore();

    // Screen-space combo display (in zoomed coordinates)
    if (combo >= 5) {
        ctx.font = 'bold 22px Comic Sans MS, cursive'; ctx.textAlign = 'center';
        ctx.fillStyle = `hsl(${frame*5%360}, 100%, 60%)`;
        ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
        ctx.strokeText('x' + combo + ' COMBO!', vw()/2, 40);
        ctx.fillText('x' + combo + ' COMBO!', vw()/2, 40);
    }

    ctx.restore(); // restore ZOOM scale

    requestAnimationFrame(render);
}

// ============= MAIN LOOP =============
function gameLoop() { update(); setTimeout(gameLoop, 1000/60); }
gameLoop(); render();
</script>
</body>
</html>
