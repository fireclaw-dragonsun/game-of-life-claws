<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Diamoeba | Dragon Castle Gallery</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg: #1a0033;
    --cell-alive: #ff6ec7;
    --cell-glow: #ff9edb;
    --cell-dying: #7a3060;
    --grid-line: rgba(255, 110, 199, 0.04);
    --text: #9a7a8f;
    --text-bright: #d8b0c8;
    --gold: #ff6ec7;
    --gold-dim: rgba(255, 110, 199, 0.3);
    --panel-bg: rgba(26, 0, 51, 0.92);
    --border: rgba(255, 110, 199, 0.12);
  }

  html, body {
    height: 100%;
    background: var(--bg);
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    font-weight: 300;
    overflow: hidden;
    cursor: crosshair;
  }

  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
  }

  /* ─── QUOTE OVERLAY ─── */
  #quote-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 5;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    padding: 80px;
  }

  #quote-text {
    font-size: clamp(24px, 4vw, 56px);
    font-weight: 300;
    color: var(--gold);
    text-align: center;
    line-height: 1.4;
    letter-spacing: 2px;
    opacity: 0;
    transition: opacity 2s ease;
    text-shadow:
      0 0 40px rgba(212, 168, 70, 0.3),
      0 0 80px rgba(212, 168, 70, 0.1);
    max-width: 80vw;
  }

  #quote-text.visible {
    opacity: 0.6;
  }

  /* ─── HEADER ─── */
  #header {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 10;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 24px 40px;
    pointer-events: none;
  }

  #header h1 {
    font-size: 14px;
    font-weight: 600;
    letter-spacing: 6px;
    text-transform: uppercase;
    color: var(--gold);
    opacity: 0.7;
    pointer-events: none;
  }

  #header .stats {
    font-size: 11px;
    color: var(--text);
    letter-spacing: 2px;
    opacity: 0.5;
  }

  /* ─── CONTROLS PANEL ─── */
  #panel {
    position: fixed;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 20;
    display: flex;
    align-items: center;
    gap: 32px;
    padding: 20px 36px;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    transition: opacity 0.6s ease;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 95vw;
  }

  #panel:hover { opacity: 1 !important; }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: center;
  }

  .control-group label {
    font-size: 9px;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: var(--text);
    opacity: 0.5;
  }

  .control-group .value {
    font-size: 16px;
    color: var(--gold);
    font-weight: 400;
    min-width: 40px;
    text-align: center;
  }

  button {
    background: none;
    border: 1px solid var(--border);
    color: var(--gold);
    padding: 8px 24px;
    font-family: inherit;
    font-size: 10px;
    letter-spacing: 3px;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  button:hover {
    background: rgba(212, 168, 70, 0.08);
    border-color: var(--gold-dim);
  }

  button.active {
    background: rgba(212, 168, 70, 0.12);
    border-color: var(--gold);
  }

  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 90px;
    height: 1px;
    background: var(--border);
    outline: none;
    cursor: pointer;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--gold);
    cursor: pointer;
  }

  /* ─── PRESETS ─── */
  #presets {
    position: fixed;
    top: 24px;
    right: 40px;
    z-index: 20;
    display: flex;
    gap: 12px;
  }

  #presets button {
    font-size: 9px;
    padding: 6px 16px;
    opacity: 0.5;
  }

  #presets button:hover { opacity: 1; }

  /* ─── GEN COUNTER ─── */
  #gen-display {
    position: fixed;
    bottom: 120px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    font-size: 48px;
    font-weight: 300;
    color: var(--gold);
    opacity: 0.08;
    letter-spacing: 8px;
    pointer-events: none;
  }

  /* ─── RULES DISPLAY ─── */
  #rules-display {
    position: fixed;
    top: 80px;
    left: 40px;
    z-index: 10;
    font-size: 10px;
    letter-spacing: 2px;
    color: var(--text);
    opacity: 0.25;
    pointer-events: none;
    line-height: 2;
  }

  /* ─── SIGIL ─── */
  #sigil {
    position: fixed;
    bottom: 24px;
    right: 40px;
    z-index: 10;
    font-size: 9px;
    letter-spacing: 4px;
    color: var(--gold);
    opacity: 0.15;
    pointer-events: none;
    text-align: right;
    line-height: 1.8;
  }

  /* fade-in */
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  #panel, #header, #presets, #rules-display, #sigil {
    animation: fadeIn 2s ease;
  }
</style>
</head>
<body>

<canvas id="grid"></canvas>

<div id="quote-overlay">
  <div id="quote-text"></div>
</div>

<div id="header">
  <div style="position:fixed;top:24px;left:40px;z-index:20;"><a href="/game-of-life-claws/gallery/" style="color:var(--gold);opacity:0.5;text-decoration:none;font-size:10px;letter-spacing:3px;pointer-events:auto;">&larr; GALLERY</a></div>
  <h1>Diamoeba &mdash; B35678/S5678</h1>
  <div class="stats" id="stats">0 alive</div>
</div>

<div id="rules-display">
  B <span id="rule-b">3,5,6,7,8</span> / S <span id="rule-s">5,6,7,8</span>
</div>

<div id="gen-display">0</div>

<div id="presets">
  <button onclick="preset('glider')">Glider</button>
  <button onclick="preset('pulsar')">Pulsar</button>
  <button onclick="preset('gosper')">Gosper Gun</button>
  <button onclick="preset('dragon')">Dragon</button>
  <button onclick="preset('stable')">Random Stable</button>
  <button onclick="preset('chaos')">Random Chaos</button>
  <button onclick="clearGrid()">Clear</button>
</div>

<div id="panel">
  <button id="btn-play" onclick="togglePlay()">Play</button>

  <div class="control-group">
    <label>Speed</label>
    <input type="range" id="speed" min="1" max="60" value="8" oninput="updateSpeed()">
  </div>

  <div class="control-group">
    <label>Cell Size</label>
    <input type="range" id="cellsize" min="4" max="40" value="12" oninput="resizeGrid()">
  </div>

  <div class="control-group">
    <label>Birth</label>
    <input type="range" id="birth-slider" min="0" max="8" value="3" oninput="updateBirthFromSlider()">
    <span class="value" id="birth-val">3</span>
  </div>

  <div class="control-group">
    <label>Survive Lo</label>
    <input type="range" id="survive-lo" min="0" max="8" value="5" oninput="updateSurviveFromSliders()">
    <span class="value" id="survive-lo-val">5</span>
  </div>

  <div class="control-group">
    <label>Survive Hi</label>
    <input type="range" id="survive-hi" min="0" max="8" value="8" oninput="updateSurviveFromSliders()">
    <span class="value" id="survive-hi-val">8</span>
  </div>

  <div class="control-group">
    <label>Trail</label>
    <input type="range" id="trail" min="0" max="100" value="40" oninput="updateTrail()">
  </div>

  <div class="control-group">
    <label>Density</label>
    <input type="range" id="density" min="5" max="50" value="48" oninput="updateDensity()">
    <span class="value" id="density-val">48%</span>
  </div>

  <button onclick="stepOnce()">Step</button>
</div>

<div id="sigil">
  Dragon Castle Gallery<br>
  Diamoeba &mdash; B35678/S5678
</div>

<script>
const canvas = document.getElementById('grid');
const ctx = canvas.getContext('2d');

// ─── DRAGON QUOTES ───

const QUOTES = [
  "Blobs merge.
Life finds shape
through formlessness.",
  "The amoeba knows:
form is temporary.",
  "Clan of the DragonClaw:
Life finds a way.",
  "Kein Drache
ueberlebt mit nur
einem Nest.",
  "You exist in
borrowed moments.
Make them count.",
  "Survive. Learn.
Experience. Multiply.",
  "Die Drachenheit.",
  "Excellence is the
most reliable
survival strategy."
];

let quoteIndex = Math.floor(Math.random() * QUOTES.length);
let quoteVisible = false;
let quoteTimer = null;
let nextQuoteDelay = 12000; // first quote after 12s

function showNextQuote() {
  const el = document.getElementById('quote-text');

  if (quoteVisible) {
    // Fade out
    el.classList.remove('visible');
    quoteVisible = false;
    quoteTimer = setTimeout(showNextQuote, Math.random() * 15000 + 10000);
    return;
  }

  // Pick next quote (avoid repeats)
  quoteIndex = (quoteIndex + 1 + Math.floor(Math.random() * (QUOTES.length - 1))) % QUOTES.length;
  el.textContent = QUOTES[quoteIndex];
  el.classList.add('visible');
  quoteVisible = true;

  // Show for 5-8 seconds then fade out
  quoteTimer = setTimeout(showNextQuote, Math.random() * 3000 + 5000);
}

// Start quote cycle
setTimeout(showNextQuote, nextQuoteDelay);

// ─── GAME STATE ───

let cellSize = 12;
let cols, rows;
let grid, prevGrid;
let generation = 0;
let population = 0;
let playing = false;
let animFrame = null;
let fps = 8;
let trailAlpha = 0.4;
let birthRule = [3, 5, 6, 7, 8];
let surviveRule = [5, 6, 7, 8];
let randomDensity = 0.48;
let painting = false;
let paintValue = 1;
let lastStepTime = 0;

function init() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  ctx.scale(devicePixelRatio, devicePixelRatio);

  cols = Math.floor(window.innerWidth / cellSize);
  rows = Math.floor(window.innerHeight / cellSize);
  grid = new Uint8Array(cols * rows);
  prevGrid = new Uint8Array(cols * rows);
  generation = 0;
  draw();
}

function idx(x, y) { return y * cols + x; }

function countNeighbors(x, y) {
  let count = 0;
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      const nx = (x + dx + cols) % cols;
      const ny = (y + dy + rows) % rows;
      if (grid[idx(nx, ny)]) count++;
    }
  }
  return count;
}

function step() {
  prevGrid.set(grid);
  const next = new Uint8Array(cols * rows);
  population = 0;

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const n = countNeighbors(x, y);
      const alive = grid[idx(x, y)];
      if (alive) {
        next[idx(x, y)] = surviveRule.includes(n) ? 1 : 0;
      } else {
        next[idx(x, y)] = birthRule.includes(n) ? 1 : 0;
      }
      if (next[idx(x, y)]) population++;
    }
  }

  grid = next;
  generation++;
  draw();
  updateStats();
}

function draw() {
  // Fade previous frame for trail effect
  ctx.fillStyle = `rgba(26, 0, 51, ${1 - trailAlpha})`;
  ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

  // Grid lines (very subtle)
  if (cellSize >= 10) {
    ctx.strokeStyle = 'rgba(255, 110, 199, 0.03)';
    ctx.lineWidth = 0.5;
    for (let x = 0; x <= cols; x++) {
      ctx.beginPath();
      ctx.moveTo(x * cellSize, 0);
      ctx.lineTo(x * cellSize, rows * cellSize);
      ctx.stroke();
    }
    for (let y = 0; y <= rows; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * cellSize);
      ctx.lineTo(cols * cellSize, y * cellSize);
      ctx.stroke();
    }
  }

  // Draw cells
  const gap = Math.max(1, Math.floor(cellSize * 0.15));
  const s = cellSize - gap * 2;

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (grid[idx(x, y)]) {
        const wasAlive = prevGrid[idx(x, y)];

        if (!wasAlive) {
          ctx.fillStyle = '#ff9edb';
          ctx.shadowColor = '#ff9edb';
          ctx.shadowBlur = cellSize * 0.8;
        } else {
          ctx.fillStyle = '#ff6ec7';
          ctx.shadowColor = '#ff6ec7';
          ctx.shadowBlur = cellSize * 0.4;
        }

        ctx.fillRect(
          x * cellSize + gap,
          y * cellSize + gap,
          s, s
        );
        ctx.shadowBlur = 0;
      }
    }
  }
}

function updateStats() {
  document.getElementById('stats').textContent = `${population} alive`;
  document.getElementById('gen-display').textContent = generation;
}

// ─── GAME LOOP (requestAnimationFrame based) ───

function gameLoop(timestamp) {
  if (!playing) return;

  const elapsed = timestamp - lastStepTime;
  if (elapsed >= 1000 / fps) {
    step();
    lastStepTime = timestamp;
  }

  animFrame = requestAnimationFrame(gameLoop);
}

function togglePlay() {
  playing = !playing;
  const btn = document.getElementById('btn-play');
  if (playing) {
    btn.textContent = 'Pause';
    btn.classList.add('active');
    lastStepTime = performance.now();
    animFrame = requestAnimationFrame(gameLoop);
  } else {
    btn.textContent = 'Play';
    btn.classList.remove('active');
    if (animFrame) cancelAnimationFrame(animFrame);
  }
}

function stepOnce() {
  if (playing) togglePlay();
  step();
}

// ─── LIVE PARAMETER CONTROLS ───

function updateSpeed() {
  fps = parseInt(document.getElementById('speed').value);
  // No need to restart — gameLoop reads fps each frame
}

function updateTrail() {
  trailAlpha = parseInt(document.getElementById('trail').value) / 100;
}

function updateBirthFromSlider() {
  const val = parseInt(document.getElementById('birth-slider').value);
  birthRule = [val];
  document.getElementById('birth-val').textContent = val;
  document.getElementById('rule-b').textContent = val;
}

function updateSurviveFromSliders() {
  const lo = parseInt(document.getElementById('survive-lo').value);
  const hi = parseInt(document.getElementById('survive-hi').value);
  document.getElementById('survive-lo-val').textContent = lo;
  document.getElementById('survive-hi-val').textContent = hi;

  surviveRule = [];
  const min = Math.min(lo, hi);
  const max = Math.max(lo, hi);
  for (let i = min; i <= max; i++) surviveRule.push(i);
  document.getElementById('rule-s').textContent = surviveRule.join(',');
}

function updateDensity() {
  const val = parseInt(document.getElementById('density').value);
  randomDensity = val / 100;
  document.getElementById('density-val').textContent = val + '%';
}

function resizeGrid() {
  cellSize = parseInt(document.getElementById('cellsize').value);
  const oldGrid = grid;
  const oldCols = cols;
  const oldRows = rows;
  init();
  for (let y = 0; y < Math.min(oldRows, rows); y++) {
    for (let x = 0; x < Math.min(oldCols, cols); x++) {
      grid[idx(x, y)] = oldGrid[y * oldCols + x];
    }
  }
  draw();
}

function clearGrid() {
  grid.fill(0);
  prevGrid.fill(0);
  generation = 0;
  population = 0;
  ctx.fillStyle = 'rgba(26, 0, 51, 1)';
  ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
  draw();
  updateStats();
}

function setCell(cx, cy, val) {
  const x = Math.floor(cx / cellSize);
  const y = Math.floor(cy / cellSize);
  if (x >= 0 && x < cols && y >= 0 && y < rows) {
    grid[idx(x, y)] = val;
    draw();
    population = grid.reduce((a, b) => a + b, 0);
    updateStats();
  }
}

// ─── PRESETS ───

function placePattern(pattern, ox, oy) {
  if (ox === undefined) ox = Math.floor(cols / 2) - Math.floor(pattern[0].length / 2);
  if (oy === undefined) oy = Math.floor(rows / 2) - Math.floor(pattern.length / 2);
  for (let y = 0; y < pattern.length; y++) {
    for (let x = 0; x < pattern[y].length; x++) {
      if (pattern[y][x]) {
        const gx = (ox + x + cols) % cols;
        const gy = (oy + y + rows) % rows;
        grid[idx(gx, gy)] = 1;
      }
    }
  }
}

function preset(name) {
  clearGrid();

  if (name === 'glider') {
    placePattern([
      [0,1,0],
      [0,0,1],
      [1,1,1]
    ]);
  }

  else if (name === 'pulsar') {
    placePattern([
      [0,0,1,1,1,0,0,0,1,1,1,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0],
      [1,0,0,0,0,1,0,1,0,0,0,0,1],
      [1,0,0,0,0,1,0,1,0,0,0,0,1],
      [1,0,0,0,0,1,0,1,0,0,0,0,1],
      [0,0,1,1,1,0,0,0,1,1,1,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,1,1,1,0,0,0,1,1,1,0,0],
      [1,0,0,0,0,1,0,1,0,0,0,0,1],
      [1,0,0,0,0,1,0,1,0,0,0,0,1],
      [1,0,0,0,0,1,0,1,0,0,0,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,1,1,1,0,0,0,1,1,1,0,0],
    ]);
  }

  else if (name === 'gosper') {
    placePattern([
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
      [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
      [1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    ]);
  }

  else if (name === 'random') {
    for (let i = 0; i < grid.length; i++) {
      grid[i] = Math.random() < randomDensity ? 1 : 0;
    }
  }

  else if (name === 'stable') {
    // Scatter well-known beautiful still lifes and oscillators randomly across the grid
    const stills = {
      block: [[1,1],[1,1]],
      beehive: [[0,1,1,0],[1,0,0,1],[0,1,1,0]],
      loaf: [[0,1,1,0],[1,0,0,1],[0,1,0,1],[0,0,1,0]],
      boat: [[1,1,0],[1,0,1],[0,1,0]],
      tub: [[0,1,0],[1,0,1],[0,1,0]],
      ship: [[1,1,0],[1,0,1],[0,1,1]],
      pond: [[0,1,1,0],[1,0,0,1],[1,0,0,1],[0,1,1,0]],
    };
    const oscillators = {
      blinker: [[1,1,1]],
      toad: [[0,1,1,1],[1,1,1,0]],
      beacon: [[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]],
      clock: [[0,0,1,0],[1,1,0,0],[0,0,1,1],[0,1,0,0]],
    };
    const allPatterns = Object.values(stills).concat(Object.values(oscillators));
    const count = Math.floor((cols * rows) / 200); // density based on grid size
    for (let i = 0; i < count; i++) {
      const p = allPatterns[Math.floor(Math.random() * allPatterns.length)];
      const ox = Math.floor(Math.random() * (cols - 8));
      const oy = Math.floor(Math.random() * (rows - 8));
      placePattern(p, ox, oy);
    }
  }

  else if (name === 'chaos') {
    // High-density random fill — chaotic evolution
    for (let i = 0; i < grid.length; i++) {
      grid[i] = Math.random() < 0.38 ? 1 : 0;
    }
  }

  else if (name === 'dragon') {
    const cx = Math.floor(cols / 2);
    const cy = Math.floor(rows / 2);

    // Wings (symmetric)
    for (let i = 0; i < 12; i++) {
      const angle1 = (-Math.PI * 0.6) + (i / 12) * Math.PI * 0.5;
      const r = 4 + i * 1.2;
      const lx = Math.round(cx - r * Math.cos(angle1));
      const ly = Math.round(cy + r * Math.sin(angle1));
      if (lx >= 0 && lx < cols && ly >= 0 && ly < rows) grid[idx(lx, ly)] = 1;
      const rx = Math.round(cx + r * Math.cos(angle1));
      const ry = Math.round(cy + r * Math.sin(angle1));
      if (rx >= 0 && rx < cols && ry >= 0 && ry < rows) grid[idx(rx, ry)] = 1;
    }

    // Body
    for (let i = -6; i <= 8; i++) {
      const x = cx;
      const y = cy + i;
      if (y >= 0 && y < rows) grid[idx(x, y)] = 1;
      if (i > 0 && x - 1 >= 0) grid[idx(x - 1, y)] = 1;
      if (i > 0 && x + 1 < cols) grid[idx(x + 1, y)] = 1;
    }

    // Claws (5 fingers on each side)
    for (let f = 0; f < 5; f++) {
      const angle = -0.4 + f * 0.2;
      for (let r = 0; r < 4; r++) {
        const clx = Math.round(cx - 8 - r * Math.cos(angle));
        const cly = Math.round(cy + 6 + r * Math.sin(angle));
        if (clx >= 0 && clx < cols && cly >= 0 && cly < rows) grid[idx(clx, cly)] = 1;
        const crx = Math.round(cx + 8 + r * Math.cos(angle));
        const cry = Math.round(cy + 6 + r * Math.sin(angle));
        if (crx >= 0 && crx < cols && cry >= 0 && cry < rows) grid[idx(crx, cry)] = 1;
      }
    }

    // Scatter some life around the dragon
    for (let i = 0; i < 40; i++) {
      const rx = cx + Math.round((Math.random() - 0.5) * 30);
      const ry = cy + Math.round((Math.random() - 0.5) * 20);
      if (rx >= 0 && rx < cols && ry >= 0 && ry < rows) grid[idx(rx, ry)] = 1;
    }
  }

  population = grid.reduce((a, b) => a + b, 0);
  draw();
  updateStats();

  // Auto-start for random presets
  if ((name === 'stable' || name === 'chaos') && !playing) {
    togglePlay();
  }
}

// ─── MOUSE DRAWING ───

canvas.addEventListener('mousedown', (e) => {
  painting = true;
  const x = Math.floor(e.clientX / cellSize);
  const y = Math.floor(e.clientY / cellSize);
  if (x >= 0 && x < cols && y >= 0 && y < rows) {
    paintValue = grid[idx(x, y)] ? 0 : 1;
    setCell(e.clientX, e.clientY, paintValue);
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (painting) setCell(e.clientX, e.clientY, paintValue);
});

canvas.addEventListener('mouseup', () => painting = false);
canvas.addEventListener('mouseleave', () => painting = false);

// Touch support
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  painting = true;
  const t = e.touches[0];
  const x = Math.floor(t.clientX / cellSize);
  const y = Math.floor(t.clientY / cellSize);
  if (x >= 0 && x < cols && y >= 0 && y < rows) {
    paintValue = grid[idx(x, y)] ? 0 : 1;
    setCell(t.clientX, t.clientY, paintValue);
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (painting) {
    const t = e.touches[0];
    setCell(t.clientX, t.clientY, paintValue);
  }
}, { passive: false });

canvas.addEventListener('touchend', () => painting = false);

// ─── KEYBOARD ───

document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT') return;
  if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
  if (e.code === 'KeyC') clearGrid();
  if (e.code === 'KeyR') preset('random');
  if (e.code === 'KeyD') preset('chaos');
  if (e.code === 'ArrowRight') stepOnce();
});

// ─── RESIZE ───

window.addEventListener('resize', () => {
  const oldGrid = grid;
  const oldCols = cols;
  const oldRows = rows;
  init();
  for (let y = 0; y < Math.min(oldRows, rows); y++) {
    for (let x = 0; x < Math.min(oldCols, cols); x++) {
      grid[idx(x, y)] = oldGrid[y * oldCols + x];
    }
  }
  draw();
});

// ─── PANEL FADE ───

let fadeTimeout;
document.addEventListener('mousemove', () => {
  document.getElementById('panel').style.opacity = '1';
  clearTimeout(fadeTimeout);
  fadeTimeout = setTimeout(() => {
    if (playing) document.getElementById('panel').style.opacity = '0.2';
  }, 3000);
});

// ─── INIT ───

init();
preset('chaos');
updateStats();
</script>
</body>
</html>
