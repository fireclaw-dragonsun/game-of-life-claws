<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ORBIT PONG | Dragon Castle Arcade</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    height: 100%; overflow: hidden;
    background: #0d001a;
    color: #8a7a9a;
    font-family: 'JetBrains Mono', monospace;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
  }
  /* CRT scanline overlay */
  body::after {
    content: ''; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: repeating-linear-gradient(0deg, rgba(0,0,0,0.03) 0px, rgba(0,0,0,0.03) 1px, transparent 1px, transparent 3px);
    pointer-events: none; z-index: 100;
  }
  #header {
    position: fixed; top: 0; left: 0; right: 0; z-index: 10;
    display: flex; justify-content: space-between; align-items: center;
    padding: 12px 20px; pointer-events: none;
  }
  #header h1 {
    font-size: 10px; font-weight: 600; letter-spacing: 4px;
    text-transform: uppercase; color: #b388ff; opacity: 0.6;
  }
  #header a {
    color: #b388ff; opacity: 0.4; text-decoration: none;
    font-size: 9px; letter-spacing: 2px; pointer-events: auto;
    transition: opacity 0.3s;
  }
  #header a:hover { opacity: 0.8; }
  canvas {
    border: 1px solid rgba(179, 136, 255, 0.12);
    cursor: none;
  }
  #sigil {
    position: fixed; bottom: 8px; right: 12px; z-index: 10;
    font-size: 7px; letter-spacing: 3px; color: #b388ff;
    opacity: 0.1; pointer-events: none; text-align: right;
  }
  #controls-hint {
    position: fixed; bottom: 8px; left: 12px; z-index: 10;
    font-size: 7px; letter-spacing: 1px; color: #8a7a9a;
    opacity: 0.3; pointer-events: none;
  }
  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  canvas, #header { animation: fadeIn 1s ease; }
</style>
</head>
<body>

<div id="header">
  <h1>ORBIT PONG</h1>
  <a href="/game-of-life-claws/gallery/">&larr; ARCADE</a>
</div>

<canvas id="game"></canvas>

<div id="sigil">Dragon Castle Arcade<br>Est. 2026</div>
<div id="controls-hint">Keyboard: Arrows/WASD + Space | Gamepad: Stick + A/B | P: Pause</div>

<script>
// ─── THEME ───
const THEME = {
  bg: '#0d001a',
  primary: '#b388ff',
  glow: '#d1b3ff',
  text: '#8a7a9a',
  textDim: 'rgba(179, 136, 255, 0.04)',
  border: 'rgba(179, 136, 255, 0.12)',
};
const GAME_TITLE = 'ORBIT PONG';
const GAME_SUBTITLE = 'Pong meets Gravity';
const GAME_CONTROLS = 'P1: Arrows / WASD  |  P2: I/K or Gamepad 2  |  P: Pause';

// ─── ENGINE MODULES ───

const rc = {
  canvas: null, ctx: null, W: 320, H: 240,

  init(w, h) {
    this.W = w || 320; this.H = h || 240;
    this.canvas = document.getElementById('game');
    this.canvas.width = this.W; this.canvas.height = this.H;
    this.canvas.style.imageRendering = 'pixelated';
    this.canvas.style.imageRendering = 'crisp-edges';
    this.ctx = this.canvas.getContext('2d');
    this.ctx.imageSmoothingEnabled = false;
    this.resize();
    window.addEventListener('resize', () => this.resize());
  },

  resize() {
    const a = this.W / this.H;
    const mw = window.innerWidth * 0.92, mh = window.innerHeight * 0.78;
    let w = mw, h = mw / a;
    if (h > mh) { h = mh; w = mh * a; }
    this.canvas.style.width = Math.floor(w) + 'px';
    this.canvas.style.height = Math.floor(h) + 'px';
  },

  clear(color) {
    this.ctx.fillStyle = color || THEME.bg;
    this.ctx.fillRect(0, 0, this.W, this.H);
  }
};


const gpad = {
  pads: [null, null, null, null],
  prev: [[], [], [], []],

  poll() {
    const gps = navigator.getGamepads ? navigator.getGamepads() : [];
    for (let i = 0; i < 4; i++) {
      const g = gps[i];
      if (!g) { this.pads[i] = null; continue; }
      this.prev[i] = this.pads[i] ? this.pads[i].buttons.map(b => b.pressed) : [];
      this.pads[i] = g;
    }
  },

  axis(pi, ai, dz) {
    dz = dz || 0.15;
    const g = this.pads[pi];
    if (!g || !g.axes[ai]) return 0;
    const v = g.axes[ai];
    return Math.abs(v) < dz ? 0 : v;
  },

  btn(pi, bi) {
    const g = this.pads[pi];
    return g && g.buttons[bi] ? g.buttons[bi].pressed : false;
  },

  justPressed(pi, bi) {
    return this.btn(pi, bi) && !this.prev[pi][bi];
  },

  rumble(pi, ms, strong, weak) {
    const g = this.pads[pi];
    if (g && g.vibrationActuator) {
      try { g.vibrationActuator.playEffect('dual-rumble', {
        duration: ms || 100, strongMagnitude: strong || 0.3, weakMagnitude: weak || 0.1
      }); } catch(e) {}
    }
  }
};

window.addEventListener('gamepadconnected', () => {});
window.addEventListener('gamepaddisconnected', () => {});


const input = {
  keys: {},

  init() {
    document.addEventListener('keydown', e => { this.keys[e.code] = true; e.preventDefault(); });
    document.addEventListener('keyup', e => { this.keys[e.code] = false; });
  },

  get p1() {
    return {
      up:     this.keys['ArrowUp'] || this.keys['KeyW'] || gpad.axis(0,1) < -0.5 || gpad.btn(0,12),
      down:   this.keys['ArrowDown'] || this.keys['KeyS'] || gpad.axis(0,1) > 0.5 || gpad.btn(0,13),
      left:   this.keys['ArrowLeft'] || this.keys['KeyA'] || gpad.axis(0,0) < -0.5 || gpad.btn(0,14),
      right:  this.keys['ArrowRight'] || this.keys['KeyD'] || gpad.axis(0,0) > 0.5 || gpad.btn(0,15),
      action: this.keys['Space'] || this.keys['KeyZ'] || gpad.btn(0,0),
      alt:    this.keys['KeyX'] || this.keys['ShiftLeft'] || gpad.btn(0,1),
      pause:  gpad.justPressed(0,9),
      axisX:  gpad.axis(0,0),
      axisY:  gpad.axis(0,1),
    };
  },

  get p2() {
    return {
      up:     this.keys['KeyI'] || gpad.axis(1,1) < -0.5 || gpad.btn(1,12),
      down:   this.keys['KeyK'] || gpad.axis(1,1) > 0.5 || gpad.btn(1,13),
      left:   this.keys['KeyJ'] || gpad.axis(1,0) < -0.5 || gpad.btn(1,14),
      right:  this.keys['KeyL'] || gpad.axis(1,0) > 0.5 || gpad.btn(1,15),
      action: this.keys['KeyU'] || gpad.btn(1,0),
      alt:    this.keys['KeyO'] || gpad.btn(1,1),
      pause:  gpad.justPressed(1,9),
      axisX:  gpad.axis(1,0),
      axisY:  gpad.axis(1,1),
    };
  }
};


const particles = {
  pool: [],
  max: 200,

  emit(x, y, count, color, spread, life) {
    spread = spread || 3; life = life || 30;
    for (let i = 0; i < count && this.pool.length < this.max; i++) {
      this.pool.push({
        x, y,
        vx: (Math.random() - 0.5) * spread,
        vy: (Math.random() - 0.5) * spread,
        life: life + Math.random() * life * 0.5,
        maxLife: life,
        color: color || THEME.primary,
        size: 1 + Math.random() * 2,
      });
    }
  },

  update() {
    for (let i = this.pool.length - 1; i >= 0; i--) {
      const p = this.pool[i];
      p.x += p.vx; p.y += p.vy;
      p.vy += 0.02;
      p.life--;
      if (p.life <= 0) this.pool.splice(i, 1);
    }
  },

  draw(ctx) {
    for (const p of this.pool) {
      const a = p.life / p.maxLife;
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      ctx.fillRect(Math.floor(p.x), Math.floor(p.y), Math.ceil(p.size * a), Math.ceil(p.size * a));
    }
    ctx.globalAlpha = 1;
  }
};


const audio = {
  ctx: null, enabled: true,

  init() {
    const unlock = () => {
      if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      document.removeEventListener('click', unlock);
      document.removeEventListener('keydown', unlock);
    };
    document.addEventListener('click', unlock);
    document.addEventListener('keydown', unlock);
  },

  beep(freq, dur, type, vol) {
    if (!this.ctx || !this.enabled) return;
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.type = type || 'square';
    o.frequency.value = freq;
    g.gain.setValueAtTime(vol || 0.08, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
    o.connect(g); g.connect(this.ctx.destination);
    o.start(); o.stop(this.ctx.currentTime + dur);
  },

  hit()     { this.beep(440, 0.08, 'square'); },
  wall()    { this.beep(280, 0.06, 'triangle'); },
  score()   { this.beep(880, 0.12, 'triangle'); setTimeout(() => this.beep(1100, 0.12, 'triangle'), 80); },
  die()     { this.beep(150, 0.3, 'sawtooth', 0.12); },
  powerup() { this.beep(600, 0.08, 'sine'); setTimeout(() => this.beep(900, 0.08, 'sine'), 60); },
  start()   { this.beep(440, 0.08, 'square'); setTimeout(() => this.beep(660, 0.08, 'square'), 100); setTimeout(() => this.beep(880, 0.12, 'square'), 200); },
};


const game = {
  state: 'title',  // title, playing, paused, gameover
  score: 0,
  hiScore: 0,
  lives: 3,
  level: 1,
  _update: null,
  _draw: null,
  _lastTime: 0,
  _targetFPS: 60,
  _dt: 0,

  run(updateFn, drawFn, fps) {
    this._update = updateFn;
    this._draw = drawFn;
    this._targetFPS = fps || 60;
    this._lastTime = performance.now();
    this._loop(this._lastTime);
  },

  _loop(now) {
    requestAnimationFrame(t => this._loop(t));
    gpad.poll();
    const elapsed = now - this._lastTime;
    if (elapsed < 1000 / this._targetFPS) return;
    this._lastTime = now;
    this._dt = Math.min(elapsed / (1000 / this._targetFPS), 3);

    // Pause toggle
    if (input.p1.pause && this.state === 'playing') { this.state = 'paused'; return; }
    if (input.p1.pause && this.state === 'paused') { this.state = 'playing'; return; }
    if (input.keys['KeyP'] && this.state === 'playing') { this.state = 'paused'; input.keys['KeyP'] = false; return; }
    if (input.keys['KeyP'] && this.state === 'paused') { this.state = 'playing'; input.keys['KeyP'] = false; return; }

    if (this.state === 'playing') {
      this._update(this._dt);
    }
    particles.update();
    this._draw(rc.ctx);
    particles.draw(rc.ctx);
    this._drawHUD(rc.ctx);
  },

  _drawHUD(ctx) {
    ctx.font = '8px monospace';

    if (this.state === 'title') {
      ctx.fillStyle = THEME.primary;
      ctx.textAlign = 'center';
      ctx.font = 'bold 16px monospace';
      ctx.fillText(GAME_TITLE, rc.W/2, rc.H/2 - 30);
      ctx.font = '8px monospace';
      ctx.fillStyle = THEME.text;
      ctx.fillText(GAME_SUBTITLE || 'Dragon Castle Arcade', rc.W/2, rc.H/2 - 10);
      ctx.fillStyle = THEME.primary;
      const blink = Math.floor(Date.now() / 500) % 2;
      if (blink) ctx.fillText('PRESS START / SPACE', rc.W/2, rc.H/2 + 20);
      ctx.font = '6px monospace';
      ctx.fillStyle = THEME.textDim;
      ctx.fillText(GAME_CONTROLS || 'Keyboard: Arrows/WASD + Space | Gamepad: Stick + A', rc.W/2, rc.H/2 + 45);
      ctx.textAlign = 'left';
      if (input.p1.action || input.keys['Enter']) { this.state = 'playing'; audio.start(); }
      return;
    }

    if (this.state === 'paused') {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, 0, rc.W, rc.H);
      ctx.fillStyle = THEME.primary;
      ctx.textAlign = 'center';
      ctx.font = 'bold 12px monospace';
      ctx.fillText('PAUSED', rc.W/2, rc.H/2);
      ctx.font = '8px monospace';
      ctx.fillStyle = THEME.text;
      ctx.fillText('Press P or Start', rc.W/2, rc.H/2 + 16);
      ctx.textAlign = 'left';
      return;
    }

    if (this.state === 'gameover') {
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0, 0, rc.W, rc.H);
      ctx.fillStyle = THEME.primary;
      ctx.textAlign = 'center';
      ctx.font = 'bold 14px monospace';
      ctx.fillText('GAME OVER', rc.W/2, rc.H/2 - 12);
      ctx.font = '8px monospace';
      ctx.fillText('Score: ' + this.score, rc.W/2, rc.H/2 + 6);
      if (this.hiScore > 0) {
        ctx.fillStyle = THEME.text;
        ctx.fillText('Best: ' + this.hiScore, rc.W/2, rc.H/2 + 20);
      }
      ctx.fillStyle = THEME.primary;
      const blink = Math.floor(Date.now() / 500) % 2;
      if (blink) ctx.fillText('PRESS START / SPACE', rc.W/2, rc.H/2 + 40);
      ctx.textAlign = 'left';
      if (input.p1.action || input.keys['Enter']) {
        if (this.score > this.hiScore) this.hiScore = this.score;
        this.state = 'playing';
        this.score = 0; this.lives = 3; this.level = 1;
        if (typeof gameReset === 'function') gameReset();
        audio.start();
      }
      return;
    }

    // In-game HUD
    ctx.fillStyle = THEME.primary;
    ctx.textAlign = 'left';
    ctx.fillText('SCORE ' + this.score, 4, 10);
    ctx.textAlign = 'right';
    if (this.lives >= 0) ctx.fillText('x' + this.lives, rc.W - 4, 10);
    ctx.textAlign = 'left';
  },
};


// ─── GAME CODE ───

// ═══════════════════════════════════════════════════
//  ORBIT PONG — Pong meets Gravity
//  Dragon Castle Arcade · Est. 2026
// ═══════════════════════════════════════════════════

// ── State ──

const pong = {
  ball: null,
  p1: null,
  p2: null,
  well: null,
  serving: 0,
  serveDir: 1,
  maxScore: 7,
  rally: 0,
  p2Human: false,
};

// ── Juice ──

let hitstop = 0;
let flashTimer = 0;
const shake = { x: 0, y: 0 };
const popups = [];

function addShake(intensity) {
  shake.x = (Math.random() - 0.5) * intensity;
  shake.y = (Math.random() - 0.5) * intensity;
}

function addPopup(x, y, text) {
  popups.push({ x: x, y: y, text: text, life: 45 });
}

// ── Ball Factory ──

function newBall(dir) {
  const spd = 1.8 + game.level * 0.12;
  return {
    x: rc.W / 2,
    y: rc.H / 2 + (Math.random() - 0.5) * 40,
    vx: spd * dir,
    vy: (Math.random() - 0.5) * 1.0,
    trail: [],
    spd: spd,
  };
}

// ── Lifecycle ──

function gameInit() {
  pong.p1 = { x: 8,  y: rc.H / 2 - 20, w: 4, h: 40, score: 0 };
  pong.p2 = { x: rc.W - 12, y: rc.H / 2 - 20, w: 4, h: 40, score: 0 };
  pong.well = { x: rc.W / 2, y: rc.H / 2, r: 10 };
  pong.ball = newBall(1);
  pong.serving = 60;
  pong.rally = 0;
}

function gameReset() {
  pong.p1.score = 0;
  pong.p2.score = 0;
  pong.ball = newBall(1);
  pong.serving = 60;
  pong.rally = 0;
  game.level = 1;
  popups.length = 0;
  hitstop = 0;
  flashTimer = 0;
  shake.x = 0;
  shake.y = 0;
}

function serve(dir) {
  pong.ball = newBall(dir);
  pong.serving = 50;
  pong.rally = 0;
}

// ── Update ──

function gameUpdate(dt) {
  // Hitstop freeze (juice)
  if (hitstop > 0) { hitstop--; return; }

  // Serve countdown
  if (pong.serving > 0) { pong.serving -= dt; return; }

  const b = pong.ball;
  const p1 = pong.p1;
  const p2 = pong.p2;
  const w = pong.well;
  const padSpeed = 3;

  // ── Player 1 Input ──
  const pi = input.p1;
  if (pi.up)   p1.y -= padSpeed * dt;
  if (pi.down) p1.y += padSpeed * dt;
  // Analog stick smooth control
  if (Math.abs(pi.axisY) > 0.1) p1.y += pi.axisY * padSpeed * dt;
  p1.y = Math.max(14, Math.min(rc.H - p1.h, p1.y));

  // ── Player 2: AI or Human ──
  const p2i = input.p2;
  pong.p2Human = gpad.pads[1] !== null || p2i.up || p2i.down;

  if (pong.p2Human) {
    if (p2i.up)   p2.y -= padSpeed * dt;
    if (p2i.down) p2.y += padSpeed * dt;
    if (Math.abs(p2i.axisY) > 0.1) p2.y += p2i.axisY * padSpeed * dt;
  } else {
    // AI: predicts ball Y linearly (ignores gravity — player's advantage)
    const lookAhead = Math.max(3, 14 - game.level * 2);
    const target = b.y + b.vy * lookAhead;
    const aiCenter = p2.y + p2.h / 2;
    const diff = target - aiCenter;
    const aiSpd = 1.2 + game.level * 0.2;

    if (b.vx > 0) {
      // Ball approaching — track it
      p2.y += Math.sign(diff) * Math.min(Math.abs(diff), aiSpd) * dt;
    } else {
      // Ball going away — drift toward center (ready position)
      const cDiff = rc.H / 2 - aiCenter;
      p2.y += Math.sign(cDiff) * Math.min(Math.abs(cDiff), 0.5) * dt;
    }
  }
  p2.y = Math.max(14, Math.min(rc.H - p2.h, p2.y));

  // ── Gravity ──
  const dx = w.x - b.x;
  const dy = w.y - b.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const minDist = w.r + 5;
  const G = 500 + game.level * 80;

  if (dist > minDist) {
    const force = G / (dist * dist);
    b.vx += (dx / dist) * force * dt;
    b.vy += (dy / dist) * force * dt;
  } else {
    // Ball hit the gravity well — bounce outward with energy
    const nx = (b.x - w.x) / dist;
    const ny = (b.y - w.y) / dist;
    b.vx = nx * b.spd * 1.8;
    b.vy = ny * b.spd * 1.8;
    b.x = w.x + nx * (minDist + 3);
    b.y = w.y + ny * (minDist + 3);
    particles.emit(w.x + nx * w.r, w.y + ny * w.r, 18, THEME.primary, 5, 25);
    audio.hit();
    addShake(6);
    hitstop = 2;
    flashTimer = 3;
  }

  // ── Speed cap ──
  const spd = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
  const maxSpd = 4.5 + game.level * 0.4;
  if (spd > maxSpd) {
    b.vx = (b.vx / spd) * maxSpd;
    b.vy = (b.vy / spd) * maxSpd;
  }

  // Prevent stall near well
  if (spd < 0.5) {
    const angle = Math.atan2(b.vy, b.vx);
    b.vx = Math.cos(angle) * b.spd;
    b.vy = Math.sin(angle) * b.spd;
  }

  // ── Trail ──
  b.trail.push({ x: b.x, y: b.y });
  if (b.trail.length > 20) b.trail.shift();

  // ── Move ──
  b.x += b.vx * dt;
  b.y += b.vy * dt;

  // ── Wall bounce (top/bottom) ──
  if (b.y <= 2) {
    b.y = 2;
    b.vy = Math.abs(b.vy);
    audio.wall();
    particles.emit(b.x, 1, 5, THEME.primary, 2, 12);
    addShake(2);
  }
  if (b.y >= rc.H - 6) {
    b.y = rc.H - 6;
    b.vy = -Math.abs(b.vy);
    audio.wall();
    particles.emit(b.x, rc.H - 1, 5, THEME.primary, 2, 12);
    addShake(2);
  }

  // ── Paddle collision: P1 (left) ──
  if (b.vx < 0 &&
      b.x <= p1.x + p1.w + 1 && b.x >= p1.x - 2 &&
      b.y + 4 >= p1.y && b.y <= p1.y + p1.h) {
    b.x = p1.x + p1.w + 2;
    const hitPos = (b.y - p1.y) / p1.h - 0.5;  // -0.5 to 0.5
    b.vx = Math.abs(b.vx) * 1.05 + 0.1;
    b.vy += hitPos * 2.5;
    pong.rally++;
    audio.hit();
    addShake(3);
    hitstop = 2;
    flashTimer = 2;
    particles.emit(p1.x + p1.w, b.y, 8, THEME.primary, 2, 15);
    gpad.rumble(0, 80, 0.3, 0.1);
    if (pong.rally > 1) addPopup(b.x + 12, b.y - 4, '+' + (pong.rally * 10));
  }

  // ── Paddle collision: P2 (right) ──
  if (b.vx > 0 &&
      b.x + 4 >= p2.x - 1 && b.x <= p2.x + p2.w + 2 &&
      b.y + 4 >= p2.y && b.y <= p2.y + p2.h) {
    b.x = p2.x - 5;
    const hitPos = (b.y - p2.y) / p2.h - 0.5;
    b.vx = -Math.abs(b.vx) * 1.05 - 0.1;
    b.vy += hitPos * 2.5;
    pong.rally++;
    audio.hit();
    addShake(3);
    hitstop = 2;
    flashTimer = 2;
    particles.emit(p2.x, b.y, 8, THEME.primary, 2, 15);
    gpad.rumble(1, 80, 0.3, 0.1);
  }

  // ── Scoring ──

  // P2 scores (ball exits left)
  if (b.x < -10) {
    p2.score++;
    pong.rally = 0;
    audio.score();
    particles.emit(0, b.y, 20, THEME.primary, 5, 30);
    addShake(5);
    if (p2.score >= pong.maxScore) {
      game.state = 'gameover';
      audio.die();
    } else {
      serve(-1);
    }
  }

  // P1 scores (ball exits right)
  if (b.x > rc.W + 10) {
    p1.score++;
    const pts = 100 + pong.rally * 10;
    game.score += pts;
    addPopup(rc.W - 30, b.y, '+' + pts);
    pong.rally = 0;
    audio.score();
    particles.emit(rc.W, b.y, 20, THEME.primary, 5, 30);
    addShake(5);

    if (p1.score >= pong.maxScore) {
      // Level up — new orbit
      game.level++;
      game.score += 500;
      addPopup(rc.W / 2, rc.H / 2 - 20, 'ORBIT ' + game.level);
      p1.score = 0;
      p2.score = 0;
      audio.powerup();
      serve(1);
      pong.serving = 90;
    } else {
      serve(1);
    }
  }

  // ── Popups tick ──
  for (let i = popups.length - 1; i >= 0; i--) {
    popups[i].y -= 0.4;
    popups[i].life--;
    if (popups[i].life <= 0) popups.splice(i, 1);
  }
}

// ── Draw ──

function gameDraw(ctx) {
  rc.clear();

  // Screen shake
  ctx.save();
  ctx.translate(Math.round(shake.x), Math.round(shake.y));
  shake.x *= 0.85;
  shake.y *= 0.85;
  if (Math.abs(shake.x) < 0.3) shake.x = 0;
  if (Math.abs(shake.y) < 0.3) shake.y = 0;

  const b = pong.ball;
  const p1 = pong.p1;
  const p2 = pong.p2;
  const w = pong.well;

  // ── Center dashed line ──
  ctx.fillStyle = THEME.textDim;
  for (let y = 0; y < rc.H; y += 8) {
    ctx.fillRect(rc.W / 2, y, 1, 4);
  }

  // ── Gravity field rings ──
  const pulse = 0.5 + 0.3 * Math.sin(Date.now() / 400);
  ctx.strokeStyle = THEME.primary;
  ctx.lineWidth = 0.5;
  for (let r = 25; r < 90; r += 18) {
    ctx.globalAlpha = 0.04 * pulse;
    ctx.beginPath();
    ctx.arc(w.x, w.y, r, 0, Math.PI * 2);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // ── Gravity well glow ──
  ctx.globalAlpha = pulse * 0.1;
  ctx.fillStyle = THEME.primary;
  ctx.beginPath();
  ctx.arc(w.x, w.y, w.r * 4, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // ── Gravity well core ──
  ctx.fillStyle = THEME.primary;
  ctx.beginPath();
  ctx.arc(w.x, w.y, w.r, 0, Math.PI * 2);
  ctx.fill();

  // Inner bright spot
  ctx.fillStyle = '#fff';
  ctx.globalAlpha = 0.5;
  ctx.beginPath();
  ctx.arc(w.x - 2, w.y - 2, w.r * 0.35, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // ── Ball trail ──
  for (let i = 0; i < b.trail.length; i++) {
    const t = b.trail[i];
    const a = (i + 1) / b.trail.length;
    ctx.globalAlpha = a * 0.35;
    ctx.fillStyle = THEME.primary;
    const s = Math.max(1, Math.floor(3 * a));
    ctx.fillRect(
      Math.floor(t.x) + Math.floor((4 - s) / 2),
      Math.floor(t.y) + Math.floor((4 - s) / 2),
      s, s
    );
  }
  ctx.globalAlpha = 1;

  // ── Ball ──
  if (pong.serving <= 0 || Math.floor(Date.now() / 200) % 2) {
    ctx.fillStyle = flashTimer > 0 ? '#fff' : THEME.primary;
    if (flashTimer > 0) flashTimer--;
    ctx.fillRect(Math.floor(b.x), Math.floor(b.y), 4, 4);
    // Bright center
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = 0.4;
    ctx.fillRect(Math.floor(b.x) + 1, Math.floor(b.y) + 1, 2, 2);
    ctx.globalAlpha = 1;
  }

  // ── Paddles ──
  ctx.fillStyle = THEME.primary;
  ctx.fillRect(p1.x, Math.floor(p1.y), p1.w, p1.h);
  ctx.fillRect(p2.x, Math.floor(p2.y), p2.w, p2.h);
  // Edge highlights
  ctx.fillStyle = '#fff';
  ctx.globalAlpha = 0.25;
  ctx.fillRect(p1.x + p1.w - 1, Math.floor(p1.y), 1, p1.h);
  ctx.fillRect(p2.x, Math.floor(p2.y), 1, p2.h);
  ctx.globalAlpha = 1;

  // ── Scores (large, faded, centered) ──
  ctx.font = 'bold 20px monospace';
  ctx.textAlign = 'center';
  ctx.fillStyle = THEME.primary;
  ctx.globalAlpha = 0.2;
  ctx.fillText(String(p1.score), rc.W / 2 - 28, 32);
  ctx.fillText(String(p2.score), rc.W / 2 + 28, 32);
  ctx.globalAlpha = 1;

  // ── Score popups ──
  ctx.font = 'bold 8px monospace';
  ctx.textAlign = 'center';
  for (const p of popups) {
    ctx.globalAlpha = p.life / 45;
    ctx.fillStyle = THEME.primary;
    ctx.fillText(p.text, Math.floor(p.x), Math.floor(p.y));
  }
  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';

  // ── Serve indicator ──
  if (pong.serving > 0 && Math.floor(Date.now() / 300) % 2) {
    ctx.fillStyle = THEME.primary;
    ctx.font = '8px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GET READY', rc.W / 2, rc.H - 16);
    ctx.textAlign = 'left';
  }

  // ── Level indicator ──
  if (game.level > 1) {
    ctx.fillStyle = THEME.primary;
    ctx.font = '6px monospace';
    ctx.textAlign = 'center';
    ctx.globalAlpha = 0.35;
    ctx.fillText('ORBIT ' + game.level, rc.W / 2, rc.H - 4);
    ctx.globalAlpha = 1;
    ctx.textAlign = 'left';
  }

  // ── P2 label ──
  ctx.font = '5px monospace';
  ctx.fillStyle = THEME.textDim;
  ctx.globalAlpha = 0.5;
  ctx.textAlign = 'right';
  ctx.fillText(pong.p2Human ? 'P2' : 'CPU', rc.W - 4, 22);
  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';

  ctx.restore();  // end screen shake
}


// ─── BOOT ───
input.init();
audio.init();
rc.init(320, 240);
if (typeof gameInit === 'function') gameInit();
game.run(
  typeof gameUpdate === 'function' ? gameUpdate : () => {},
  typeof gameDraw === 'function' ? gameDraw : () => {},
  60
);
</script>
</body>
</html>