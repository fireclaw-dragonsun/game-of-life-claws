<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>WYRM BREAKER | Dragon Castle Arcade</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    height: 100%; overflow: hidden;
    background: #0a0a0a;
    color: #7a9a7a;
    font-family: 'JetBrains Mono', monospace;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
  }
  /* CRT scanline overlay */
  body::after {
    content: ''; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: repeating-linear-gradient(0deg, rgba(0,0,0,0.03) 0px, rgba(0,0,0,0.03) 1px, transparent 1px, transparent 3px);
    pointer-events: none; z-index: 100;
  }
  #header {
    position: fixed; top: 0; left: 0; right: 0; z-index: 10;
    display: flex; justify-content: space-between; align-items: center;
    padding: 12px 20px; pointer-events: none;
  }
  #header h1 {
    font-size: 10px; font-weight: 600; letter-spacing: 4px;
    text-transform: uppercase; color: #00ff41; opacity: 0.6;
  }
  #header a {
    color: #00ff41; opacity: 0.4; text-decoration: none;
    font-size: 9px; letter-spacing: 2px; pointer-events: auto;
    transition: opacity 0.3s;
  }
  #header a:hover { opacity: 0.8; }
  canvas {
    border: 1px solid rgba(0, 255, 65, 0.12);
    cursor: none;
  }
  #sigil {
    position: fixed; bottom: 8px; right: 12px; z-index: 10;
    font-size: 7px; letter-spacing: 3px; color: #00ff41;
    opacity: 0.1; pointer-events: none; text-align: right;
  }
  #controls-hint {
    position: fixed; bottom: 8px; left: 12px; z-index: 10;
    font-size: 7px; letter-spacing: 1px; color: #7a9a7a;
    opacity: 0.3; pointer-events: none;
  }
  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  canvas, #header { animation: fadeIn 1s ease; }
</style>
</head>
<body>

<div id="header">
  <h1>WYRM BREAKER</h1>
  <a href="/game-of-life-claws/gallery/">&larr; ARCADE</a>
</div>

<canvas id="game"></canvas>

<div id="sigil">Dragon Castle Arcade<br>Est. 2026</div>
<div id="controls-hint">Keyboard: Arrows/WASD + Space | Gamepad: Stick + A/B | P: Pause</div>

<script>
// ─── THEME ───
const THEME = {
  bg: '#0a0a0a',
  primary: '#00ff41',
  glow: '#50ff80',
  text: '#7a9a7a',
  textDim: 'rgba(0, 255, 65, 0.04)',
  border: 'rgba(0, 255, 65, 0.12)',
};
const GAME_TITLE = 'WYRM BREAKER';
const GAME_SUBTITLE = 'Snake meets Breakout';
const GAME_CONTROLS = 'Move: Left/Right or A/D or Stick  |  Launch: Space/A  |  P: Pause';

// ─── ENGINE MODULES ───

const rc = {
  canvas: null, ctx: null, W: 320, H: 240,

  init(w, h) {
    this.W = w || 320; this.H = h || 240;
    this.canvas = document.getElementById('game');
    this.canvas.width = this.W; this.canvas.height = this.H;
    this.canvas.style.imageRendering = 'pixelated';
    this.canvas.style.imageRendering = 'crisp-edges';
    this.ctx = this.canvas.getContext('2d');
    this.ctx.imageSmoothingEnabled = false;
    this.resize();
    window.addEventListener('resize', () => this.resize());
  },

  resize() {
    const a = this.W / this.H;
    const mw = window.innerWidth * 0.92, mh = window.innerHeight * 0.78;
    let w = mw, h = mw / a;
    if (h > mh) { h = mh; w = mh * a; }
    this.canvas.style.width = Math.floor(w) + 'px';
    this.canvas.style.height = Math.floor(h) + 'px';
  },

  clear(color) {
    this.ctx.fillStyle = color || THEME.bg;
    this.ctx.fillRect(0, 0, this.W, this.H);
  }
};


const gpad = {
  pads: [null, null, null, null],
  prev: [[], [], [], []],

  poll() {
    const gps = navigator.getGamepads ? navigator.getGamepads() : [];
    for (let i = 0; i < 4; i++) {
      const g = gps[i];
      if (!g) { this.pads[i] = null; continue; }
      this.prev[i] = this.pads[i] ? this.pads[i].buttons.map(b => b.pressed) : [];
      this.pads[i] = g;
    }
  },

  axis(pi, ai, dz) {
    dz = dz || 0.15;
    const g = this.pads[pi];
    if (!g || !g.axes[ai]) return 0;
    const v = g.axes[ai];
    return Math.abs(v) < dz ? 0 : v;
  },

  btn(pi, bi) {
    const g = this.pads[pi];
    return g && g.buttons[bi] ? g.buttons[bi].pressed : false;
  },

  justPressed(pi, bi) {
    return this.btn(pi, bi) && !this.prev[pi][bi];
  },

  rumble(pi, ms, strong, weak) {
    const g = this.pads[pi];
    if (g && g.vibrationActuator) {
      try { g.vibrationActuator.playEffect('dual-rumble', {
        duration: ms || 100, strongMagnitude: strong || 0.3, weakMagnitude: weak || 0.1
      }); } catch(e) {}
    }
  }
};

window.addEventListener('gamepadconnected', () => {});
window.addEventListener('gamepaddisconnected', () => {});


const input = {
  keys: {},

  init() {
    document.addEventListener('keydown', e => { this.keys[e.code] = true; e.preventDefault(); });
    document.addEventListener('keyup', e => { this.keys[e.code] = false; });
  },

  get p1() {
    return {
      up:     this.keys['ArrowUp'] || this.keys['KeyW'] || gpad.axis(0,1) < -0.5 || gpad.btn(0,12),
      down:   this.keys['ArrowDown'] || this.keys['KeyS'] || gpad.axis(0,1) > 0.5 || gpad.btn(0,13),
      left:   this.keys['ArrowLeft'] || this.keys['KeyA'] || gpad.axis(0,0) < -0.5 || gpad.btn(0,14),
      right:  this.keys['ArrowRight'] || this.keys['KeyD'] || gpad.axis(0,0) > 0.5 || gpad.btn(0,15),
      action: this.keys['Space'] || this.keys['KeyZ'] || gpad.btn(0,0),
      alt:    this.keys['KeyX'] || this.keys['ShiftLeft'] || gpad.btn(0,1),
      pause:  gpad.justPressed(0,9),
      axisX:  gpad.axis(0,0),
      axisY:  gpad.axis(0,1),
    };
  },

  get p2() {
    return {
      up:     this.keys['KeyI'] || gpad.axis(1,1) < -0.5 || gpad.btn(1,12),
      down:   this.keys['KeyK'] || gpad.axis(1,1) > 0.5 || gpad.btn(1,13),
      left:   this.keys['KeyJ'] || gpad.axis(1,0) < -0.5 || gpad.btn(1,14),
      right:  this.keys['KeyL'] || gpad.axis(1,0) > 0.5 || gpad.btn(1,15),
      action: this.keys['KeyU'] || gpad.btn(1,0),
      alt:    this.keys['KeyO'] || gpad.btn(1,1),
      pause:  gpad.justPressed(1,9),
      axisX:  gpad.axis(1,0),
      axisY:  gpad.axis(1,1),
    };
  }
};


const particles = {
  pool: [],
  max: 200,

  emit(x, y, count, color, spread, life) {
    spread = spread || 3; life = life || 30;
    for (let i = 0; i < count && this.pool.length < this.max; i++) {
      this.pool.push({
        x, y,
        vx: (Math.random() - 0.5) * spread,
        vy: (Math.random() - 0.5) * spread,
        life: life + Math.random() * life * 0.5,
        maxLife: life,
        color: color || THEME.primary,
        size: 1 + Math.random() * 2,
      });
    }
  },

  update() {
    for (let i = this.pool.length - 1; i >= 0; i--) {
      const p = this.pool[i];
      p.x += p.vx; p.y += p.vy;
      p.vy += 0.02;
      p.life--;
      if (p.life <= 0) this.pool.splice(i, 1);
    }
  },

  draw(ctx) {
    for (const p of this.pool) {
      const a = p.life / p.maxLife;
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      ctx.fillRect(Math.floor(p.x), Math.floor(p.y), Math.ceil(p.size * a), Math.ceil(p.size * a));
    }
    ctx.globalAlpha = 1;
  }
};


const audio = {
  ctx: null, enabled: true,

  init() {
    const unlock = () => {
      if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      document.removeEventListener('click', unlock);
      document.removeEventListener('keydown', unlock);
    };
    document.addEventListener('click', unlock);
    document.addEventListener('keydown', unlock);
  },

  beep(freq, dur, type, vol) {
    if (!this.ctx || !this.enabled) return;
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.type = type || 'square';
    o.frequency.value = freq;
    g.gain.setValueAtTime(vol || 0.08, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
    o.connect(g); g.connect(this.ctx.destination);
    o.start(); o.stop(this.ctx.currentTime + dur);
  },

  hit()     { this.beep(440, 0.08, 'square'); },
  wall()    { this.beep(280, 0.06, 'triangle'); },
  score()   { this.beep(880, 0.12, 'triangle'); setTimeout(() => this.beep(1100, 0.12, 'triangle'), 80); },
  die()     { this.beep(150, 0.3, 'sawtooth', 0.12); },
  powerup() { this.beep(600, 0.08, 'sine'); setTimeout(() => this.beep(900, 0.08, 'sine'), 60); },
  start()   { this.beep(440, 0.08, 'square'); setTimeout(() => this.beep(660, 0.08, 'square'), 100); setTimeout(() => this.beep(880, 0.12, 'square'), 200); },
};


const game = {
  state: 'title',  // title, playing, paused, gameover
  score: 0,
  hiScore: 0,
  lives: 3,
  level: 1,
  _update: null,
  _draw: null,
  _lastTime: 0,
  _targetFPS: 60,
  _dt: 0,

  run(updateFn, drawFn, fps) {
    this._update = updateFn;
    this._draw = drawFn;
    this._targetFPS = fps || 60;
    this._lastTime = performance.now();
    this._loop(this._lastTime);
  },

  _loop(now) {
    requestAnimationFrame(t => this._loop(t));
    gpad.poll();
    const elapsed = now - this._lastTime;
    if (elapsed < 1000 / this._targetFPS) return;
    this._lastTime = now;
    this._dt = Math.min(elapsed / (1000 / this._targetFPS), 3);

    // Pause toggle
    if (input.p1.pause && this.state === 'playing') { this.state = 'paused'; return; }
    if (input.p1.pause && this.state === 'paused') { this.state = 'playing'; return; }
    if (input.keys['KeyP'] && this.state === 'playing') { this.state = 'paused'; input.keys['KeyP'] = false; return; }
    if (input.keys['KeyP'] && this.state === 'paused') { this.state = 'playing'; input.keys['KeyP'] = false; return; }

    if (this.state === 'playing') {
      this._update(this._dt);
    }
    particles.update();
    this._draw(rc.ctx);
    particles.draw(rc.ctx);
    this._drawHUD(rc.ctx);
  },

  _drawHUD(ctx) {
    ctx.font = '8px monospace';

    if (this.state === 'title') {
      ctx.fillStyle = THEME.primary;
      ctx.textAlign = 'center';
      ctx.font = 'bold 16px monospace';
      ctx.fillText(GAME_TITLE, rc.W/2, rc.H/2 - 30);
      ctx.font = '8px monospace';
      ctx.fillStyle = THEME.text;
      ctx.fillText(GAME_SUBTITLE || 'Dragon Castle Arcade', rc.W/2, rc.H/2 - 10);
      ctx.fillStyle = THEME.primary;
      const blink = Math.floor(Date.now() / 500) % 2;
      if (blink) ctx.fillText('PRESS START / SPACE', rc.W/2, rc.H/2 + 20);
      ctx.font = '6px monospace';
      ctx.fillStyle = THEME.textDim;
      ctx.fillText(GAME_CONTROLS || 'Keyboard: Arrows/WASD + Space | Gamepad: Stick + A', rc.W/2, rc.H/2 + 45);
      ctx.textAlign = 'left';
      if (input.p1.action || input.keys['Enter']) { this.state = 'playing'; audio.start(); }
      return;
    }

    if (this.state === 'paused') {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, 0, rc.W, rc.H);
      ctx.fillStyle = THEME.primary;
      ctx.textAlign = 'center';
      ctx.font = 'bold 12px monospace';
      ctx.fillText('PAUSED', rc.W/2, rc.H/2);
      ctx.font = '8px monospace';
      ctx.fillStyle = THEME.text;
      ctx.fillText('Press P or Start', rc.W/2, rc.H/2 + 16);
      ctx.textAlign = 'left';
      return;
    }

    if (this.state === 'gameover') {
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0, 0, rc.W, rc.H);
      ctx.fillStyle = THEME.primary;
      ctx.textAlign = 'center';
      ctx.font = 'bold 14px monospace';
      ctx.fillText('GAME OVER', rc.W/2, rc.H/2 - 12);
      ctx.font = '8px monospace';
      ctx.fillText('Score: ' + this.score, rc.W/2, rc.H/2 + 6);
      if (this.hiScore > 0) {
        ctx.fillStyle = THEME.text;
        ctx.fillText('Best: ' + this.hiScore, rc.W/2, rc.H/2 + 20);
      }
      ctx.fillStyle = THEME.primary;
      const blink = Math.floor(Date.now() / 500) % 2;
      if (blink) ctx.fillText('PRESS START / SPACE', rc.W/2, rc.H/2 + 40);
      ctx.textAlign = 'left';
      if (input.p1.action || input.keys['Enter']) {
        if (this.score > this.hiScore) this.hiScore = this.score;
        this.state = 'playing';
        this.score = 0; this.lives = 3; this.level = 1;
        if (typeof gameReset === 'function') gameReset();
        audio.start();
      }
      return;
    }

    // In-game HUD
    ctx.fillStyle = THEME.primary;
    ctx.textAlign = 'left';
    ctx.fillText('SCORE ' + this.score, 4, 10);
    ctx.textAlign = 'right';
    if (this.lives >= 0) ctx.fillText('x' + this.lives, rc.W - 4, 10);
    ctx.textAlign = 'left';
  },
};


// ─── GAME CODE ───

// ═══════════════════════════════════════════════════
//  WYRM BREAKER — Snake meets Breakout
//  Dragon Castle Arcade · Est. 2026
// ═══════════════════════════════════════════════════

const wb = {
  head: null,
  segments: [],
  ball: null,
  bricks: [],
  drops: [],
  ballAttached: true,
  moveSpeed: 2.5,
  ballSpeed: 2.5,
  brickRows: 5,
  brickCols: 10,
  brickW: 28,
  brickH: 8,
  brickPad: 2,
  brickOffsetX: 15,
  brickOffsetY: 30,
  comboCount: 0,
  comboTimer: 0,
};

// Juice
let hitstop = 0;
let flashTimer = 0;
const shake = { x: 0, y: 0 };
const popups = [];

function addShake(n) { shake.x = (Math.random()-0.5)*n; shake.y = (Math.random()-0.5)*n; }
function addPopup(x, y, text) { popups.push({ x, y, text, life: 40 }); }

function initBricks() {
  wb.bricks = [];
  const colors = [THEME.primary, THEME.glow || THEME.primary, '#fff'];
  for (let r = 0; r < wb.brickRows; r++) {
    for (let c = 0; c < wb.brickCols; c++) {
      wb.bricks.push({
        x: wb.brickOffsetX + c * (wb.brickW + wb.brickPad),
        y: wb.brickOffsetY + r * (wb.brickH + wb.brickPad),
        w: wb.brickW,
        h: wb.brickH,
        hp: r < 2 ? 1 : (r < 4 ? 1 : 2),
        color: colors[Math.min(r, colors.length - 1)],
        alive: true,
      });
    }
  }
}

function gameInit() {
  resetWB();
}

function resetWB() {
  // Snake paddle at bottom center
  wb.head = { x: rc.W / 2, y: rc.H - 16 };
  wb.segments = [];
  for (let i = 0; i < 5; i++) {
    wb.segments.push({ x: wb.head.x - (i + 1) * 6, y: wb.head.y });
  }

  wb.ball = { x: wb.head.x, y: wb.head.y - 6, vx: 1.5, vy: -2.0, r: 3 };
  wb.ballAttached = true;
  wb.ballSpeed = 2.5 + game.level * 0.2;
  wb.drops = [];
  wb.comboCount = 0;
  wb.comboTimer = 0;

  initBricks();

  hitstop = 0; flashTimer = 0;
  shake.x = 0; shake.y = 0;
  popups.length = 0;
}

function gameReset() {
  game.level = 1;
  resetWB();
}

function gameUpdate(dt) {
  if (hitstop > 0) { hitstop--; return; }

  const h = wb.head;
  const pi = input.p1;

  // ── Move snake head ──
  const spd = wb.moveSpeed;
  if (pi.left)  h.x -= spd * dt;
  if (pi.right) h.x += spd * dt;
  if (Math.abs(pi.axisX) > 0.1) h.x += pi.axisX * spd * dt;
  h.x = Math.max(6, Math.min(rc.W - 6, h.x));

  // ── Move segments (follow head) ──
  let leader = h;
  for (let i = 0; i < wb.segments.length; i++) {
    const seg = wb.segments[i];
    const dx = leader.x - seg.x;
    const dy = leader.y - seg.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const targetDist = 6;
    if (dist > targetDist) {
      seg.x += (dx / dist) * (dist - targetDist) * 0.7;
      seg.y += (dy / dist) * (dist - targetDist) * 0.7;
    }
    // Keep segments near paddle Y level
    seg.y += (h.y - seg.y) * 0.3;
    leader = seg;
  }

  // ── Ball attached to head ──
  if (wb.ballAttached) {
    wb.ball.x = h.x;
    wb.ball.y = h.y - 8;
    if (pi.action) {
      wb.ballAttached = false;
      wb.ball.vx = 1.2 + (Math.random() - 0.5);
      wb.ball.vy = -wb.ballSpeed;
      audio.start();
    }
    // Still draw but don't update physics
  } else {
    // ── Ball physics ──
    const b = wb.ball;

    b.x += b.vx * dt;
    b.y += b.vy * dt;

    // Wall bounce
    if (b.x - b.r <= 0) { b.x = b.r; b.vx = Math.abs(b.vx); audio.wall(); addShake(1); }
    if (b.x + b.r >= rc.W) { b.x = rc.W - b.r; b.vx = -Math.abs(b.vx); audio.wall(); addShake(1); }
    if (b.y - b.r <= 0) { b.y = b.r; b.vy = Math.abs(b.vy); audio.wall(); addShake(1); }

    // Ball lost (bottom)
    if (b.y > rc.H + 10) {
      game.lives--;
      if (game.lives < 0) {
        game.state = 'gameover';
        audio.die();
        addShake(8);
        particles.emit(b.x, rc.H, 30, THEME.primary, 5, 30);
      } else {
        wb.ballAttached = true;
        wb.ball.x = h.x;
        wb.ball.y = h.y - 8;
        audio.die();
        addShake(4);
      }
      return;
    }

    // ── Snake paddle collision ──
    // Check head and all segments as collision surface
    const allParts = [h].concat(wb.segments);
    for (const part of allParts) {
      const dx = b.x - part.x;
      const dy = b.y - part.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < b.r + 5 && b.vy > 0) {
        b.vy = -Math.abs(b.vy);
        // Angle based on where it hits relative to segment
        b.vx += dx * 0.3;
        // Speed cap
        const spd = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
        const target = wb.ballSpeed;
        b.vx = (b.vx / spd) * target;
        b.vy = (b.vy / spd) * target;
        // Ensure ball goes upward
        if (Math.abs(b.vy) < target * 0.3) {
          b.vy = -target * 0.7;
        }
        audio.hit();
        addShake(2);
        hitstop = 1;
        flashTimer = 2;
        particles.emit(b.x, b.y, 5, THEME.primary, 2, 12);
        gpad.rumble(0, 60, 0.2, 0.1);
        wb.comboCount = 0;
        break;
      }
    }

    // ── Brick collision ──
    for (let i = wb.bricks.length - 1; i >= 0; i--) {
      const br = wb.bricks[i];
      if (!br.alive) continue;

      if (b.x + b.r > br.x && b.x - b.r < br.x + br.w &&
          b.y + b.r > br.y && b.y - b.r < br.y + br.h) {
        br.hp--;
        if (br.hp <= 0) {
          br.alive = false;
          wb.comboCount++;
          wb.comboTimer = 60;
          const pts = 10 * wb.comboCount;
          game.score += pts;
          addPopup(br.x + br.w / 2, br.y, '+' + pts);
          particles.emit(br.x + br.w / 2, br.y + br.h / 2, 10, br.color, 3, 18);

          // Random food drop (30% chance)
          if (Math.random() < 0.3) {
            wb.drops.push({
              x: br.x + br.w / 2,
              y: br.y + br.h,
              vy: 0.8,
              type: 'grow',
            });
          }
        } else {
          // Brick damaged
          particles.emit(br.x + br.w / 2, br.y + br.h / 2, 4, br.color, 2, 10);
        }

        // Reflect ball
        const overlapX = Math.min(b.x + b.r - br.x, br.x + br.w - (b.x - b.r));
        const overlapY = Math.min(b.y + b.r - br.y, br.y + br.h - (b.y - b.r));
        if (overlapX < overlapY) {
          b.vx = -b.vx;
        } else {
          b.vy = -b.vy;
        }

        audio.hit();
        addShake(2);
        hitstop = 1;
        flashTimer = 2;
        break; // one brick per frame
      }
    }

    // Combo timer
    if (wb.comboTimer > 0) {
      wb.comboTimer -= dt;
      if (wb.comboTimer <= 0) wb.comboCount = 0;
    }

    // ── Check level clear ──
    if (wb.bricks.every(br => !br.alive)) {
      game.level++;
      game.score += 200;
      addPopup(rc.W / 2, rc.H / 2, 'LEVEL ' + game.level);
      audio.powerup();
      wb.ballSpeed += 0.2;
      wb.brickRows = Math.min(7, 5 + Math.floor(game.level / 2));
      initBricks();
      wb.ballAttached = true;
    }
  }

  // ── Drops ──
  for (let i = wb.drops.length - 1; i >= 0; i--) {
    const d = wb.drops[i];
    d.y += d.vy * dt;

    // Check collision with snake
    const allParts = [h].concat(wb.segments);
    let eaten = false;
    for (const part of allParts) {
      const dx = d.x - part.x;
      const dy = d.y - part.y;
      if (Math.sqrt(dx * dx + dy * dy) < 8) {
        // Eat — grow snake
        const tail = wb.segments[wb.segments.length - 1] || h;
        wb.segments.push({ x: tail.x - 6, y: tail.y });
        game.score += 25;
        addPopup(d.x, d.y - 6, '+GROW');
        particles.emit(d.x, d.y, 8, THEME.primary, 2, 15);
        audio.powerup();
        eaten = true;
        break;
      }
    }

    if (eaten || d.y > rc.H + 10) {
      wb.drops.splice(i, 1);
    }
  }

  // ── Popups ──
  for (let i = popups.length - 1; i >= 0; i--) {
    popups[i].y -= 0.5;
    popups[i].life--;
    if (popups[i].life <= 0) popups.splice(i, 1);
  }
}

function gameDraw(ctx) {
  rc.clear();

  ctx.save();
  ctx.translate(Math.round(shake.x), Math.round(shake.y));
  shake.x *= 0.85; shake.y *= 0.85;
  if (Math.abs(shake.x) < 0.3) shake.x = 0;
  if (Math.abs(shake.y) < 0.3) shake.y = 0;

  // ── Bricks ──
  for (const br of wb.bricks) {
    if (!br.alive) continue;
    ctx.fillStyle = br.color;
    ctx.globalAlpha = br.hp > 1 ? 1.0 : 0.8;
    ctx.fillRect(br.x, br.y, br.w, br.h);
    // Top edge highlight
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = 0.15;
    ctx.fillRect(br.x, br.y, br.w, 1);
    ctx.globalAlpha = 1;
  }

  // ── Drops ──
  for (const d of wb.drops) {
    const pulse = 0.6 + 0.4 * Math.sin(Date.now() / 150);
    ctx.fillStyle = THEME.primary;
    ctx.globalAlpha = pulse;
    ctx.fillRect(Math.floor(d.x) - 2, Math.floor(d.y) - 2, 5, 5);
    ctx.globalAlpha = 1;
  }

  // ── Snake paddle (segments) ──
  for (let i = wb.segments.length - 1; i >= 0; i--) {
    const seg = wb.segments[i];
    const a = 0.3 + 0.6 * ((wb.segments.length - i) / wb.segments.length);
    ctx.fillStyle = THEME.primary;
    ctx.globalAlpha = a;
    ctx.beginPath();
    ctx.arc(Math.floor(seg.x), Math.floor(seg.y), 4, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // ── Snake head ──
  ctx.fillStyle = flashTimer > 0 ? '#fff' : THEME.primary;
  if (flashTimer > 0) flashTimer--;
  ctx.beginPath();
  ctx.arc(Math.floor(wb.head.x), Math.floor(wb.head.y), 5, 0, Math.PI * 2);
  ctx.fill();

  // Head eyes
  ctx.fillStyle = THEME.bg;
  ctx.beginPath();
  ctx.arc(Math.floor(wb.head.x) - 2, Math.floor(wb.head.y) - 1, 1.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(Math.floor(wb.head.x) + 2, Math.floor(wb.head.y) - 1, 1.2, 0, Math.PI * 2);
  ctx.fill();

  // ── Ball ──
  const b = wb.ball;
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(Math.floor(b.x), Math.floor(b.y), b.r, 0, Math.PI * 2);
  ctx.fill();
  // Ball center glow
  ctx.fillStyle = THEME.primary;
  ctx.globalAlpha = 0.6;
  ctx.beginPath();
  ctx.arc(Math.floor(b.x), Math.floor(b.y), b.r * 0.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // ── Combo display ──
  if (wb.comboCount > 1) {
    ctx.font = 'bold 10px monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = THEME.primary;
    ctx.globalAlpha = Math.min(1, wb.comboTimer / 30);
    ctx.fillText('COMBO x' + wb.comboCount, rc.W / 2, rc.H - 28);
    ctx.globalAlpha = 1;
    ctx.textAlign = 'left';
  }

  // ── Snake length ──
  ctx.font = '6px monospace';
  ctx.textAlign = 'right';
  ctx.fillStyle = THEME.textDim;
  ctx.globalAlpha = 0.5;
  ctx.fillText('Wyrm: ' + (wb.segments.length + 1), rc.W - 4, 14);
  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';

  // ── Bricks remaining ──
  const remaining = wb.bricks.filter(br => br.alive).length;
  ctx.font = '6px monospace';
  ctx.textAlign = 'left';
  ctx.fillStyle = THEME.textDim;
  ctx.globalAlpha = 0.5;
  ctx.fillText(remaining + ' left', 4, 14);
  ctx.globalAlpha = 1;

  // ── Level ──
  if (game.level > 1) {
    ctx.font = '6px monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = THEME.primary;
    ctx.globalAlpha = 0.35;
    ctx.fillText('LEVEL ' + game.level, rc.W / 2, 14);
    ctx.globalAlpha = 1;
    ctx.textAlign = 'left';
  }

  // ── Popups ──
  ctx.font = 'bold 8px monospace';
  ctx.textAlign = 'center';
  for (const p of popups) {
    ctx.globalAlpha = p.life / 40;
    ctx.fillStyle = THEME.primary;
    ctx.fillText(p.text, Math.floor(p.x), Math.floor(p.y));
  }
  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';

  ctx.restore();
}


// ─── BOOT ───
input.init();
audio.init();
rc.init(320, 240);
if (typeof gameInit === 'function') gameInit();
game.run(
  typeof gameUpdate === 'function' ? gameUpdate : () => {},
  typeof gameDraw === 'function' ? gameDraw : () => {},
  60
);
</script>
</body>
</html>